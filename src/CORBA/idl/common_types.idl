/****************************************************************************/
/* DIET IDL types for SeD registration and client request (init steps)      */
/*                                                                          */
/*  Author(s):                                                              */
/*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       */
/*    - Frederic LOMBARD (Frederic.Lombard@lifc.univ-fcomte.fr)             */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.34  2010/07/27 10:24:32  glemahec
 * Improve robustness & general performance
 *
 * Revision 1.33  2010/07/20 14:31:46  glemahec
 * Forwarder robustness + bug corrections
 *
 * Revision 1.32  2010/07/12 15:54:11  glemahec
 * DIET 2.5 beta 1 - Forwarder IDL files
 *
 * Revision 1.31  2008/09/09 10:05:56  bisnard
 * container mgmt using Dagda agent
 *
 * Revision 1.30  2008/06/25 09:52:46  bisnard
 * - Estimation vector sent with solve request to avoid storing it
 * for each submit request as it depends on the parameters value. The
 * estimation vector is used by SeD to updates internal Gantt chart and
 * provide earliest finish time to submitted requests.
 * ==> added parameter to diet_call_common & diet_call_async_common
 *
 * Revision 1.29  2008/04/07 15:33:41  ycaniou
 * This should remove all HAVE_BATCH occurences (still appears in the doc, which
 *   must be updated.. soon :)
 * Add the definition of DIET_BATCH_JOBID wariable in batch scripts
 *
 * Revision 1.28  2008/04/06 15:53:10  glemahec
 * DIET_PERSISTENT_RETURN & DIET_STICKY_RETURN modes are now working.
 * Warning: The clients have to take into account that an out data declared as
 * DIET_PERSISTENT or DIET_STICKY is  only stored on the SeDs and not returned
 * to  the  client. DTM doesn't manage the  DIET_*_RETURN types it and  always
 * returns the out data to the client: A client which uses this bug should not
 * work when activating DAGDA.
 *
 * Revision 1.27  2008/04/03 21:18:41  glemahec
 * Source cleaning, bug correction and headers.
 *
 * Revision 1.26  2008/01/19 01:40:35  glemahec
 * Reverting the previous commit for DTM. DTM doesn't seem to support the
 * bug correction...
 * Warning : When using DTM, undefined result may appear when using data of
 * size > 2GB...
 * DAGDA still uses the correction.
 *
 * Revision 1.25  2008/01/18 15:28:34  glemahec
 * Bug correction:
 * 	"long" => "unsigned long long" (<=> size_t) for all the data sizes
 * 	fields.
 *
 * Revision 1.24  2008/01/14 10:31:22  glemahec
 * Adds the "dataManager" field in the corba_data_desc_t object to differentiate
 * the replicas of a data.
 *
 * Revision 1.23  2007/07/13 16:44:40  ecaron
 * Remove deprecated code (ALTPREDICT part)
 *
 * Revision 1.22  2007/06/28 18:23:19  rbolze
 * add dietReqID in the profile.
 * and propagate this change to all functions that  have both reqID and profile parameters.
 * TODO : look at the asynchronous mechanism (client->SED) to propage this change.
 *
 * Revision 1.21  2007/04/16 22:43:43  ycaniou
 * Make all necessary changes to have the new option HAVE_ALT_BATCH operational.
 * This is indented to replace HAVE_BATCH.
 *
 * First draw to manage batch systems with a new Cori plug-in.
 *
 * Revision 1.20  2007/03/26 13:25:17  glemahec
 * Adds the definition of corba_agg_user_t aggregator type and modification of the corba_agg_specific_t type. Conditioned to USERSCHED definition.
 *
 * Revision 1.19  2006/08/27 18:40:10  ycaniou
 * Modified parallel submission API
 * - client: diet_call_batch() -> diet_parallel_call()
 * - SeD: diet_profile_desc_set_batch() -> [...]_parallel()
 * - from now, internal fields are related to parallel not batch
 * and corrected a bug:
 * - 3 types of submission: request among only seq, only parallel, or all
 *   available services (second wasn't implemented, third bug)
 *
 * Revision 1.18  2006/07/25 14:26:08  ycaniou
 * Changed dietJobID -> dietReqID
 *
 * Revision 1.17  2006/06/03 21:13:58  ycaniou
 * Batch: add nbprocess field to corba structures
 *
 * Revision 1.16  2006/04/14 14:14:06  aamar
 * Adding the IDL data structures for workflow support.
 *
 * Revision 1.15  2006/04/12 16:12:28  ycaniou
 * Put back the right common_types.idl and made C commentaries from C++
 *   (discard compilation warnings)
 *
 * Revision 1.12  2005/08/31 14:52:54  alsu
 * New plugin scheduling interface: new data model for the estimation
 * vector, with each data entry containing three elements:
 *  - the data tag
 *  - the data index (>=0 indicating an array value, <0 indicating a
 *    scalar value)
 *  - the data value
 *
 * Revision 1.11  2005/08/30 12:05:15  ycaniou
 * Added a field dietJobId to make the correspondance between batch ID and
 *   diet job ID.
 * Added the corresponding management in marshalling.
 *
 * Revision 1.10  2005/05/15 15:33:30  alsu
 * CORBA versions of the aggregator (+ some cleanup)
 *
 * Revision 1.9  2005/04/27 01:04:55  ycaniou
 * Added solve_batch() to the SeD API
 * Modified corba profile structures
 *
 * Revision 1.8  2005/01/14 10:42:26  lphilipp
 *
 * correction bug 13
 *
 * Revision 1.7  2004/12/08 15:02:51  alsu
 * plugin scheduler first-pass validation testing complete.  merging into
 * main CVS trunk; ready for more rigorous testing.
 *
 * Revision 1.6.2.4  2004/11/24 09:32:38  alsu
 * adding CORBA support (new datatype in the IDL and corresponding
 * marshalling/unmarshalling functions) to deal with
 * DIET_PARAMSTRING-specific data description structure
 *
 * Revision 1.6.2.3  2004/11/02 00:29:35  alsu
 * removing all hard-coded fields from corba_estimation_t (code elsewhere
 * modified to use the estValues dynamic estimation value vector)
 *
 * Revision 1.6.2.2  2004/10/27 22:35:50  alsu
 * include
 *
 * Revision 1.6.2.1  2004/10/26 14:12:52  alsu
 * (Tag: AS-plugin-sched)
 *  - branch created to avoid conflicting with release 1.2 (imminent)
 *  - initial commit on branch, new dynamic performance info structure in
 *    the profile
 *
 * Revision 1.6  2004/09/29 13:35:31  sdahan
 * Add the Multi-MAs feature.
 *
 * Revision 1.5  2003/09/24 09:07:52  pcombes
 * Merge corba_DataMgr_desc_t and corba_data_desc_t.
 *
 * Revision 1.4  2003/09/22 21:06:54  pcombes
 * Add the type corba_data_id_t for data persistency.
 *
 * Revision 1.3  2003/09/18 09:47:19  bdelfabr
 * adding data persistence
 *
 * Revision 1.2  2003/08/01 19:27:26  pcombes
 * Add the field nbCPU to the estimation (got from FAST 0.8)
 *
 * Revision 1.1  2003/04/10 12:17:45  pcombes
 * Replace common_types.idl : IDL structures for service, problem and
 * request description (inc. estimation).
 *
 ****************************************************************************/


#ifndef _COMMON_TYPES_IDL_
#define _COMMON_TYPES_IDL_

typedef sequence<any>    SeqAny;
typedef sequence<double> SeqDouble;
typedef sequence<long>   SeqLong;
typedef sequence<char>   SeqChar;
typedef sequence<string> SeqString;

/* The object name is not valid. */
exception BadNameException {
	string name;
	string function;
	string forwarder_name;
};
/* The name does not refer to a registered object. */
exception UnknownObject {
	string name;
};

/****************************************************************************/
/* DATA PERISTENCY: Data Description for Data Manager                       */
/****************************************************************************/

/** State of the data */
enum occupationFlag {DIET_FREE, DIET_INUSE, DIET_TRANSFERT};
/**
 * Flag used to manage data coherence: data only registered on one Data Manager
 */
enum kleenexFlag {DIET_ORIGINAL, DIET_KLEENEXCOPY};

/** Structure of the Data Identifier */
struct corba_data_id_t {
  string idNumber;
  kleenexFlag dataCopy;
  occupationFlag state;
};


/****************************************************************************/
/* REGISTRATON _ Data description                                           */
/* Mapping for the diet_data_desc_t type                                    */
/****************************************************************************/

/** Simple complex mapping */
struct corba_scomplex_t {
  float r;
  float i;
};
/** Double complex mapping */
struct corba_dcomplex_t {
  double r;
  double i;
};

/** Mapping for struct diet_scalar_specific */
struct corba_scalar_specific_t {
  any value;
};

/** Mapping for struct diet_vector_specific */
struct corba_vector_specific_t {
  unsigned long long size;
};

/** Mapping fo structr diet_matrix_specific */
struct corba_matrix_specific_t {
  unsigned long long nb_r;
  unsigned long long nb_c;
  unsigned long order;
};

/** Mapping for struct diet_string_specific */
struct corba_string_specific_t {
  unsigned long length;
};

/** Mapping for struct diet_paramstring_specific */
struct corba_paramstring_specific_t {
  unsigned long length;
  string param;
};

/** Mapping for struct diet_file_specific */
struct corba_file_specific_t {
  unsigned long long size;
  string path;
};

/** Mapping for struct diet_container_specific */
struct corba_container_specific_t {
  unsigned long long size;
};

/**
 * Descriptor
 * The field 'type' in diet_data_desc_t is the discriminant of union field
 */
union type switch (long) {
 case 0:
   corba_scalar_specific_t scal;
 case 1:
   corba_vector_specific_t vect;
 case 2:
   corba_matrix_specific_t mat;
 case 3:
   corba_string_specific_t str;
 case 4:
   corba_paramstring_specific_t pstr;
 case 5:
   corba_file_specific_t   file;
 case 6:
   corba_container_specific_t   cont;
};

struct corba_data_desc_t {
  corba_data_id_t id;
  long mode;
  long base_type;
  type specific;
  string dataManager; // This data Dagda data manager name.
  short byte_order;
  short base_type_size;
};
typedef sequence<corba_data_desc_t> SeqCorbaDataDesc_t;


/****************************************************************************/
/* REGISTRATON _ Service description                                        */
/****************************************************************************/

/** Argument descriptor */
struct corba_arg_desc_t {
  long base_type;
  long type;
};

/*
** server estimate aggregation
*/
struct corba_agg_default_t {
  octet dummy;
};
struct corba_agg_priority_t {
  sequence<long> priorityList;
};
/** New : The aggregator for user scheduler support.      */
/** The same as the default aggregator. Maybe not needed. */
#ifdef USERSCHED
struct corba_agg_user_t {
  octet dummy;
};
#endif
/**********************************************************/
union corba_agg_specific_t switch (long) {
 case 0:
   corba_agg_default_t agg_default;
 case 1:
   corba_agg_priority_t agg_priority;
/** New : The aggregator for user scheduler support. */
#ifdef USERSCHED
 case 2:
   corba_agg_user_t agg_user;
#endif
/*****************************************************/
};
struct corba_aggregator_desc_t {
  corba_agg_specific_t agg_specific;
};

/** Service profile descriptor (mapping for diet_profile_desc_t) */
struct corba_profile_desc_t {
  string path;
  long   last_in;
  long   last_inout;
  long   last_out;
  sequence<corba_arg_desc_t> param_desc;
#if HAVE_ALT_BATCH
  long parallel_flag ;
#endif
  corba_aggregator_desc_t aggregator;
};
typedef sequence<corba_profile_desc_t> SeqCorbaProfileDesc_t;



/****************************************************************************/
/* REQUEST _ Problem profile description                                    */
/****************************************************************************/

/** Mapping for diet_data_t */
struct corba_data_t {
  corba_data_desc_t desc;
  SeqChar value;
};
typedef sequence<corba_data_t> SeqCorbaData_t;

/**
 * Actually, this is an equivalent to a diet_profile_t without the data.
 */
struct corba_pb_desc_t {
  string path;
  long   last_in;
  long   last_inout;
  long   last_out;
  SeqCorbaDataDesc_t param_desc;
#if HAVE_ALT_BATCH
  long   parallel_flag ;
  long   nbprocs ;
  long   nbprocess ;
  long   walltime ;
#endif
};

/****************************************************************************/
/* REQUEST                                                                  */
/****************************************************************************/
/**
 * A request is associated to an ID, a problem description, and a scheduler.
 */
struct corba_request_t {
  unsigned long     reqID;
  corba_pb_desc_t   pb;
  string            serialized_scheduler;
  long              max_srv;
};


/****************************************************************************/
/* ESTIMATION                                                               */
/****************************************************************************/
/**
 * Custom estimation tags: space of a char, acceptable values
 * defined DIET_data_internal.h
 */
typedef short corba_est_tag_storage_t;

/**
 * Custom estimation value
 */
struct corba_est_value_t {
  corba_est_tag_storage_t v_tag;
  short                   v_idx;
  double                  v_value;
};
typedef sequence <corba_est_value_t> SeqEstValue_t;

/**
 * The estimation structure
 * commTimes == Communication times of ALL parameters :
 * the tranfer time of OUT parameters is estimated as if they were IN,
 * which is better than not taking them into account.
 *
 * totalTime stores all communication times + tComp
 */
struct corba_estimation_t {
  /* dynamic storage for performance estimation values */
  SeqEstValue_t estValues;
};

#ifdef HAVE_WORKFLOW
/** The workflow description structure. */
struct corba_wf_desc_t {
  string abstract_wf;
};
#endif

/****************************************************************************/
/* PROFILE (for problem solve)                                              */
/****************************************************************************/

/** The complete problem, sent from client to server. */
struct corba_profile_t {
  long   last_in;
  long   last_inout;
  long   last_out;
  SeqCorbaData_t parameters;
  unsigned long dietReqID ;
  corba_estimation_t estim;
#if HAVE_ALT_BATCH
  long   parallel_flag ;
  long   nbprocs ;
  long   nbprocess ;
  long   walltime ;
#endif
  string clientName;
};

#endif // _COMMON_TYPES_IDL_

