/****************************************************************************/
/* DIET IDL types for the responses to requests                             */
/*                                                                          */
/*  Author(s):                                                              */
/*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       */
/*    - Frederic LOMBARD (Frederic.Lombard@lifc.univ-fcomte.fr)             */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.6  2005/09/05 15:54:51  hdail
 * Addition of data location information to response (experimental and
 * protected by HAVE_ALTPREDICT)
 *
 * Revision 1.5  2005/08/30 12:05:15  ycaniou
 * Added a field dietJobId to make the correspondance between batch ID and
 *   diet job ID.
 * Added the corresponding management in marshalling.
 *
 * Revision 1.4  2004/10/15 08:17:36  hdail
 * Removed sortedIndexes field of corba_response_t -- no longer useful in DIET.
 *
 * Revision 1.3  2004/06/11 15:45:39  ctedesch
 * add DIET/JXTA
 *
 * Revision 1.2  2003/05/13 17:14:49  pcombes
 * reqID is unsigned long.
 *
 * Revision 1.1  2003/04/10 12:18:02  pcombes
 * IDL response structure.
 *
 ****************************************************************************/


#ifndef _RESPONSE_IDL_
#define _RESPONSE_IDL_

#include "common_types.idl"
#include "SeD.idl"


/**
 * Full reference to a server
 */

struct corba_server_t {
  SeD    ior;
  string hostName;
#if HAVE_ALTPREDICT
  string locationID; // For alternative data transfer prediction
#endif
#if HAVE_JXTA
  string uuid;
#endif // HAVE_JXTA
  long   port;
};


/**
 * Localization and transfer time of a parameter
 */
struct corba_data_loc_t {
  string idNumber;
  string hostName;
  string locationID;
  unsigned long bytes;
  //corba_server_t loc;
  //double         timeToMe;
};
typedef sequence <corba_data_loc_t> SeqDataLoc_t;


/**
 * The server estimation structure 
 */

struct corba_server_estimation_t{
  corba_server_t     loc;
  corba_estimation_t estim;
};

typedef sequence <corba_server_estimation_t> SeqServerEstimation_t;


/****************************************************************************/
/* RESPONSE                                                                 */
/****************************************************************************/
/**
 * The servers are sorted as follows:
 *   the first part of the servers sequence consists of all servers where the
 *   computation could be estimated,
 *   whereas the second part consists of all the ones that provide only an
 *   estimation of their free resources.
 * Actually the servers are not sorted in the "servers" sequence itself : 
 *   it is far cheaper to maintain sorted a sequence of indexes, with an apart
 *   long field that stores the number of servers where the computation could be
 *   estimated (nbComp).
 * Thus, for each i between 0 and nbComp, the computation on the server
 *   servers[sortedServers[i]] was estimated and the result is stored in
 *   servers[sortedServers[i]].perf().tComp
 * For i between nbComp and servers.length(), free resources on the server
 *   servers[sortedServers[i]] was estimated and the results are stored in
 *   servers[sortedServers[i]].perf.feeCpu and freeMem
 */

struct corba_response_t {
  unsigned long reqID;
  long myID;
  // The available servers
  SeqServerEstimation_t servers;
#if HAVE_ALTPREDICT
  // Localization of parameters for agent transfer time predictions 
  SeqDataLoc_t        dataLoc;
#endif
#ifdef HAVE_BATCH
  // Make client know he has to submit batch or non-batch
  long batch_flag ;
#endif
};

#endif // _RESPONSE_IDL_
