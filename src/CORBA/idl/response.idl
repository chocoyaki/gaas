/****************************************************************************/
/* DIET IDL types for the responses to requests                             */
/*                                                                          */
/*  Author(s):                                                              */
/*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       */
/*    - Frederic LOMBARD (Frederic.Lombard@lifc.univ-fcomte.fr)             */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.18  2010/07/12 15:54:11  glemahec
 * DIET 2.5 beta 1 - Forwarder IDL files
 *
 * Revision 1.17  2009/02/06 14:51:55  bisnard
 * setup exceptions for workflows
 *
 * Revision 1.16  2008/06/25 09:54:49  bisnard
 * obsolete params used for DietLogComponent in wf_response
 *
 * Revision 1.15  2008/04/19 09:16:45  ycaniou
 * Check that pathToTmp and pathToNFS exist
 * Check and eventually correct if pathToTmp or pathToNFS finish or not by '/'
 * Rewrite of the propagation of the request concerning job parallel_flag
 * Rewrite (and addition) of the propagation of the response concerning:
 *   job parallel_flag and serverType (batch or serial for the moment)
 * Complete debug info with batch stuff
 *
 * Revision 1.14  2008/04/10 08:17:14  bisnard
 * New version of the MaDag where workflow node execution is triggered by the MaDag agent and done by a new CORBA object CltWfMgr located in the client
 *
 * Revision 1.13  2008/04/07 15:33:41  ycaniou
 * This should remove all HAVE_BATCH occurences (still appears in the doc, which
 *   must be updated.. soon :)
 * Add the definition of DIET_BATCH_JOBID wariable in batch scripts
 *
 * Revision 1.12  2007/07/13 16:44:40  ecaron
 * Remove deprecated code (ALTPREDICT part)
 *
 * Revision 1.11  2007/04/16 22:43:43  ycaniou
 * Make all necessary changes to have the new option HAVE_ALT_BATCH operational.
 * This is indented to replace HAVE_BATCH.
 *
 * First draw to manage batch systems with a new Cori plug-in.
 *
 * Revision 1.10  2006/11/06 12:11:47  aamar
 * Worklow support: Changing the  wf_sched_response_t structure.
 *
 * Revision 1.9  2006/10/20 08:09:05  aamar
 * Extending the wf_response_t.
 * Adding the new structure wf_sched_response_t.
 *
 * Revision 1.8  2006/08/27 18:40:10  ycaniou
 * Modified parallel submission API
 * - client: diet_call_batch() -> diet_parallel_call()
 * - SeD: diet_profile_desc_set_batch() -> [...]_parallel()
 * - from now, internal fields are related to parallel not batch
 * and corrected a bug:
 * - 3 types of submission: request among only seq, only parallel, or all
 *   available services (second wasn't implemented, third bug)
 *
 * Revision 1.7  2006/04/14 14:14:06  aamar
 * Adding the IDL data structures for workflow support.
 *
 * Revision 1.5  2005/08/30 12:05:15  ycaniou
 * Added a field dietJobId to make the correspondance between batch ID and
 *   diet job ID.
 * Added the corresponding management in marshalling.
 *
 * Revision 1.4  2004/10/15 08:17:36  hdail
 * Removed sortedIndexes field of corba_response_t -- no longer useful in DIET.
 *
 * Revision 1.3  2004/06/11 15:45:39  ctedesch
 * add DIET/JXTA
 *
 * Revision 1.2  2003/05/13 17:14:49  pcombes
 * reqID is unsigned long.
 *
 * Revision 1.1  2003/04/10 12:18:02  pcombes
 * IDL response structure.
 *
 ****************************************************************************/


#ifndef _RESPONSE_IDL_
#define _RESPONSE_IDL_

#include "common_types.idl"
#include "SeD.idl"

/**
 * Full reference to a server
 */

struct corba_server_t {
  string SeDName;
  string hostName;
  long   port;
#ifdef HAVE_ALT_BATCH
  // To add the following, SeDStructures.idl which contains shared structures
  // between SeD and DIET_server.h has to be created
  //diet_server_status_t serverType ; /* batch, seq, etc. */
  long serverType ;

  // Make client know he has to submit parallel or non-parallel
  long parallel_flag ;
#endif
};


/**
 * Localization and transfer time of a parameter
 */
struct corba_data_loc_t {
  string idNumber;
  string hostName;
  string locationID;
  unsigned long bytes;
  //corba_server_t loc;
  //double         timeToMe;
};
typedef sequence <corba_data_loc_t> SeqDataLoc_t;


/**
 * The server estimation structure
 */

struct corba_server_estimation_t{
  corba_server_t     loc;
  corba_estimation_t estim;
};

typedef sequence <corba_server_estimation_t> SeqServerEstimation_t;


/****************************************************************************/
/* RESPONSE                                                                 */
/****************************************************************************/
/**
 * The servers are sorted as follows:
 *   the first part of the servers sequence consists of all servers where the
 *   computation could be estimated,
 *   whereas the second part consists of all the ones that provide only an
 *   estimation of their free resources.
 * Actually the servers are not sorted in the "servers" sequence itself :
 *   it is far cheaper to maintain sorted a sequence of indexes, with an apart
 *   long field that stores the number of servers where the computation could be
 *   estimated (nbComp).
 * Thus, for each i between 0 and nbComp, the computation on the server
 *   servers[sortedServers[i]] was estimated and the result is stored in
 *   servers[sortedServers[i]].perf().tComp
 * For i between nbComp and servers.length(), free resources on the server
 *   servers[sortedServers[i]] was estimated and the results are stored in
 *   servers[sortedServers[i]].perf.feeCpu and freeMem
 */

struct corba_response_t {
  unsigned long reqID;
  long myID;
  // The available servers
  SeqServerEstimation_t servers;
};

#ifdef HAVE_WORKFLOW
/*************************************************************************/
/* for workflow support                                                  */
/*************************************************************************/
typedef sequence<corba_pb_desc_t> corba_pb_desc_seq_t;

struct corba_extended_response_t {
    corba_pb_desc_t       problem;
    SeqServerEstimation_t servers;
};

typedef sequence<corba_extended_response_t> response_seq_t;

struct node_response_t {
    string node_id;
    double node_priority;
    corba_server_estimation_t server;
};

typedef sequence<node_response_t> dag_response_t;

struct wf_node_response_t {
  string node_id;
  double node_priority;
  corba_response_t response;
};

typedef sequence <wf_node_response_t> wfn_seq_resp_t;

struct wf_response_t {
  boolean complete;
  long    idxError;
  wfn_seq_resp_t wfn_seq_resp;
};

#endif // HAVE_WORKFLOW

#endif // _RESPONSE_IDL_
