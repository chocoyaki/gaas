/****************************************************************************/
/* DIET master agent implementation source code                             */
/*                                                                          */
/*  Author(s):                                                              */
/*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       */
/*    - Sylvain DAHAN (Sylvain.Dahan@lifc.univ-fcomte.fr)                   */
/*    - Frederic LOMBARD (Frederic.Lombard@lifc.univ-fcomte.fr)             */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.68  2011/02/09 15:09:55  hguemar
 * configuration backend changed again: more CONFIG_XXX
 *
 * Revision 1.67  2011/02/04 15:20:48  hguemar
 * fixes to new configuration parser
 * some cleaning
 *
 * Revision 1.66  2011/01/21 16:47:16  bdepardo
 * Prefer prefix ++/-- operators for non-primitive types.
 *
 * Revision 1.65  2010/12/17 09:48:00  kcoulomb
 * * Set diet to use the new log with forwarders
 * * Fix a CoRI problem
 * * Add library version remove DTM flag from ccmake because deprecated
 *
 * Revision 1.64  2010/12/08 15:49:45  bdepardo
 * Added missing include in Multi-MA mode
 *
 * Revision 1.63  2010/11/24 15:18:08  bdepardo
 * searchData is now available on all agents. SeDs are now able to retrieve
 * a DAGDA data from an alias specified by a client.
 * Currently a SeD cannot declare an alias.
 *
 * Revision 1.62  2010/07/27 12:43:07  glemahec
 * Bugs corrections
 *
 * Revision 1.61  2010/07/27 10:24:33  glemahec
 * Improve robustness & general performance
 *
 * Revision 1.60  2010/07/12 20:14:32  glemahec
 * DIET 2.5 beta 1 - Forwarders with Multi-MAs bug correction
 *
 * Revision 1.59  2010/07/12 16:14:11  glemahec
 * DIET 2.5 beta 1 - Use the new ORB manager and allow the use of SSH-forwarders for all DIET CORBA objects
 *
 * Revision 1.58  2010/05/07 07:40:47  bdepardo
 * Remove a warning about a cast from string constant to char*.
 *
 * Revision 1.57  2010/03/03 10:19:03  bdepardo
 * Changed \n into endl
 *
 * Revision 1.56  2009/10/16 16:43:23  bdepardo
 * Added "***.." in traces.
 *
 * Revision 1.55  2009/10/05 08:36:59  bdepardo
 * Added stats for multi-MA
 *
 * Revision 1.54  2009/03/27 09:29:30  bisnard
 * submit_pb_set: provide service info when service missing
 *
 * Revision 1.53  2008/07/10 13:08:23  glemahec
 * Warning fixed in MasterAgentImpl.cc
 *
 * Revision 1.52  2008/07/10 11:42:10  bisnard
 * Fix bug 68 memory loss during workflow execution
 *
 * Revision 1.51  2008/06/25 09:55:56  bisnard
 * removed unused parameter in submit_pb_set & corrected bug with ReqIDs
 *
 * Revision 1.50  2008/06/01 15:49:20  rbolze
 * update msg in stat_in stat_out fonction
 * add info about the reqID (normaly thread safe)
 *
 * Revision 1.49  2008/06/01 14:06:56  rbolze
 * replace most ot the cout by adapted function from debug.cc
 * there are some left ...
 *
 * Revision 1.48  2008/05/31 08:45:16  rbolze
 * comment message send through logService
 *
 * Revision 1.47  2008/05/23 11:55:03  glemahec
 * 64 bits CORBA mapping bug correction.
 *
 * Revision 1.46  2008/05/06 13:39:33  glemahec
 * DAGDA API extension.
 *
 * Revision 1.45  2008/04/29 22:22:02  glemahec
 * DAGDA improvements :
 *   - Asynchronous API.
 *   - Data ID alias managing.
 *   - Data manager state backup and restore.
 *
 * Revision 1.44  2008/04/28 07:08:30  glemahec
 * The DAGDA API.
 *
 * Revision 1.43  2008/04/19 10:44:33  glemahec
 * With DAGDA, the data ID are generated by the uuid library when available.
 *
 * Revision 1.42  2008/04/19 09:16:45  ycaniou
 * Check that pathToTmp and pathToNFS exist
 * Check and eventually correct if pathToTmp or pathToNFS finish or not by '/'
 * Rewrite of the propagation of the request concerning job parallel_flag
 * Rewrite (and addition) of the propagation of the response concerning:
 *   job parallel_flag and serverType (batch or serial for the moment)
 * Complete debug info with batch stuff
 *
 * Revision 1.41  2008/04/14 13:44:29  bisnard
 * - Parameter 'used' obsoleted in MultiWfScheduler::submit_wf & submit_pb_set
 *
 * Revision 1.40  2008/04/10 09:13:31  bisnard
 * New version of the MaDag where workflow node execution is triggered by the MaDag agent and done by a new CORBA object CltWfMgr located in the client
 *
 * Revision 1.39  2008/04/07 15:33:43  ycaniou
 * This should remove all HAVE_BATCH occurences (still appears in the doc, which
 *   must be updated.. soon :)
 * Add the definition of DIET_BATCH_JOBID wariable in batch scripts
 *
 * Revision 1.38  2008/01/14 10:02:56  glemahec
 * MasterAgentImpl.cc, the implementation of the CORBA object MasterAgent can
 * now use DAGDA instead of DTM to manage the data.
 *
 * Revision 1.37  2008/01/01 19:04:46  ycaniou
 * Only cosmetic
 *
 * Revision 1.36  2007/06/28 18:03:46  ycaniou
 * Take into account the possibility of initReqID not defined in the .cfg
 *
 * Revision 1.35  2007/06/28 17:30:25  ycaniou
 * Better with a cast
 *
 * Revision 1.34  2007/06/28 17:17:42  ycaniou
 * MAImpl.cc: reqIDCounter feature to begin the count with a given value
 * Parsers.cc: parseInt not a name
 *
 * Revision 1.33  2007/04/16 22:43:43  ycaniou
 * Make all necessary changes to have the new option HAVE_ALT_BATCH operational.
 * This is indented to replace HAVE_BATCH.
 *
 * First draw to manage batch systems with a new Cori plug-in.
 *
 * Revision 1.32  2006/12/01 10:14:07  aamar
 * Workflow support: add a test to check if ALTPREDICT is activated.
 *   Workflow support still not working when use altpredict but diet
 *   compilation will not fail when combining these two options.
 *
 * Revision 1.31  2006/11/06 15:14:53  aamar
 * Workflow support: Correct some code about reqID
 *
 * Revision 1.30  2006/11/06 12:05:47  aamar
 * Workflow support: correct the lastReqID value.
 *
 * Revision 1.29  2006/11/02 17:11:17  rbolze
 * change information send by DietLogComponent
 *
 * Revision 1.28  2006/10/24 00:08:24  aamar
 * DietLogComponent used in submit_pb_set.
 *
 * Revision 1.27  2006/10/20 08:48:59  aamar
 * Remove the submit_wf function.
 * Handle the request ID in workflow submission.
 *
 * Revision 1.26  2006/08/31 05:47:50  ycaniou
 * Last fix wasn't complete (miss one line)
 *
 * Revision 1.25  2006/08/30 15:36:08  ycaniou
 * Correction for the MasterAgent to submit a "real" copy of parallel/sequential
 *   profile in HAVE_BATCH mode
 *
 * Revision 1.24  2006/06/30 15:37:34  ycaniou
 * Code presentation, commentaries (nothing really "touched")
 *
 * Revision 1.23  2006/05/12 12:12:32  sdahan
 * Add some documentation about multi-MA
 *
 * Bug fix:
 *  - segfault when the neighbours configuration line was empty
 *  - deadlock when a MA create a link on itself
 *
 * Revision 1.22  2006/04/14 14:17:38  aamar
 * Implementing the two methods for workflow support:
 *   - submit_wf (TO REMOVE)
 *   - submit_pb_set.
 *
 * Revision 1.21  2005/09/05 16:06:56  hdail
 * Addition of client hostname and location information to submit call.
 *
 * Revision 1.20  2005/07/11 16:31:56  hdail
 * Corrected bug wherein the MA would stop completely if a client requested
 * a service that didn't exist; this bug was introduced recently, so there should
 * be no reports of it from outside users.
 *
 * Revision 1.19  2005/05/15 15:48:50  alsu
 * minor changes from estimation vector reorganization
 *
 * Revision 1.18  2005/04/08 13:02:43  hdail
 * The code for LogCentral has proven itself stable and it seems bug free.
 * Since no external libraries are required to compile in LogCentral, its now
 * going to be compiled in by default always ... its usage is easily controlled by
 * configuration file.
 *
 * Revision 1.17  2004/12/16 11:16:44  sdahan
 * adds multi-mas informations into the logService
 *
 * Revision 1.16  2004/12/15 15:57:08  sdahan
 * rewrite the FloodRequestsList to use a simplest implementation. The previous mutex bugs does not exist anymore.
 *
 * Revision 1.15  2004/12/02 08:21:07  sdahan
 * bug fix:
 *   - file id leak in the BindService
 *   - can search an service that do not existe and having MA name different to
 *     its binding name.
 * warning message added in FloodRequest:
 *   - instead of just ignoring eronous message, a warning is print in the log
 * ALL_PRINT_STEP messages added to show some Multi-MAs request
 *
 * Revision 1.14  2004/11/29 15:22:16  sdahan
 * update the hash algorithm.
 * the ls6 and ls7 had the same hash value. So two differents request had the same id. By updating the hash function, this should not append presently.
 *
 * Revision 1.13  2004/10/06 16:40:24  rbolze
 * implement function to return the Profiles avialable on platform when a client ask it
 *
 * Revision 1.12  2004/09/29 13:35:31  sdahan
 * Add the Multi-MAs feature.
 *
 * Revision 1.11  2004/06/09 15:10:38  mcolin
 * add stat_flush in statistics API in order to flush write access to
 * statistic file for agent and sed which never end and can't call
 * stat_finalize
 *
 * Revision 1.10  2004/03/01 18:46:08  rbolze
 * add logservice
 *
 * Revision 1.9  2004/02/27 10:25:11  bdelfabr
 * methods for data id creation and  methods to retrieve data descriptor are added
 *
 * Revision 1.8  2003/09/28 22:06:11  ecaron
 * Take into account the new API of statistics module
 *
 * Revision 1.7  2003/09/22 21:19:49  pcombes
 * Set all the modules and their interfaces for data persistency.
 *
 * Revision 1.4  2003/07/04 09:47:59  pcombes
 * Use new ERROR, WARNING and TRACE macros.
 *
 * Revision 1.2  2003/05/10 08:53:34  pcombes
 * New format for configuration files, new Parsers.
 *
 * Revision 1.1  2003/04/10 13:01:32  pcombes
 * Replace MasterAgent_impl.cc. Apply CS. Use ChildID, NodeDescription, Parsers,
 * Schedulers and TRACE_LEVEL. Update submit.
 * Multi-MA parts are still to be updated.
 ****************************************************************************/


#include <iostream>
#include <cstdio>

#if HAVE_DAGDA && HAVE_ADVANCED_UUID
#include <uuid/uuid.h>
#endif

#include "configuration.hh"
#include "MasterAgentImpl.hh"
#include "debug.hh"
#include "statistics.hh"
#include "ReferenceUpdateThread.hh"
#include "FloodRequestsList.hh"

#ifdef HAVE_MULTI_MA
#include "ORBMgr.hh"
#endif


#ifdef HAVE_WORKFLOW
/*
  Workflow utilities header
*/

omni_mutex reqCount_mutex ;

#endif /* HAVE_WORKFLOW */

//#define aff_val(x)
#define aff_val(x) cout << #x << " = " << x << endl;

#define MA_TRACE_FUNCTION(formatted_text)		\
    TRACE_TEXT(TRACE_ALL_STEPS, "MA::");		\
    TRACE_FUNCTION(TRACE_ALL_STEPS,formatted_text)

MasterAgentImpl::MasterAgentImpl() : AgentImpl()
{
    this->reqIDCounter = 0;
    this->num_session = 0;
    this->num_data = 0;
#ifdef HAVE_MULTI_MA
    this->floodRequestsList = new FloodRequestsList() ;
#endif /* HAVE_MULTI_MA */
} // MasterAgentImpl


MasterAgentImpl::~MasterAgentImpl()
{
#ifdef HAVE_MULTI_MA
    delete floodRequestsList ;
  //  MAList.emptyIt();
#endif /* HAVE_MULTI_MA */
} // MasterAgentImpl::~MasterAgentImpl()


/**
 * Launch this agent (initialization + registration in the hierarchy).
 */
int
MasterAgentImpl::run()
{
    int res = this->AgentImpl::run();
    if (res)
	return res;

    int tmp_val = CONFIG_INT(diet::INITREQUESTID);

    if (!tmp_val)
	this->reqIDCounter = 0 ;
    else
	this->reqIDCounter = tmp_val ;

#ifdef HAVE_MULTI_MA
    /* launch the bind service */
    unsigned int port = CONFIG_INT(diet::BINDSERVICEPORT);
    if (port) {
	bindSrv = new BindService(this, port) ;
	char* bindName = ms_stralloc(strlen(localHostName) + 20);
	sprintf(bindName, "%s:%d", localHostName, port) ;
	this->bindName = bindName ;
	reqIDCounter = KeyString::hash(bindName) ;
    } else {
	reqIDCounter = KeyString::hash(localHostName) ;
    }
    reqIDCounter = ((reqIDCounter & 0xFFFFF) ^ ((reqIDCounter >> 12) & 0xFFF))
	* 1000 ;

    /* FIXME: initRequestID is not managed in the .cfg yet */
    TRACE_TEXT(TRACE_ALL_STEPS, "Getting MAs references ..." << std::endl);

    /* get the list of neighbours */
    const std::string& neighbors = CONFIG_STRING(diet::NEIGHBOURS) ;

    // FIXME: use std::string instead
    char *neighbours = ms_strdup(neighbors.c_str()) ;
    char* comma, *begin_copy ;
    begin_copy = neighbours ;
    while((comma = strchr(neighbours, ',')) != NULL) {
	comma[0] = '\0' ;
	if(neighbours[0] != '\0')
	    MAIds.insert(CORBA::string_dup(neighbours)) ;
	neighbours = comma + 1 ;
    }
    MAIds.insert(CORBA::string_dup(neighbours)) ;
    free(begin_copy) ;

    /* initialize some variables */
    unsigned int conf = CONFIG_INT(diet::MINNEIGHBOURS);

    if (conf)
	minMAlinks = conf ;
    else
	minMAlinks = 2;
    conf = CONFIG_INT(diet::MAXNEIGHBOURS);

    if (conf)
	maxMAlinks = conf;
    else
	maxMAlinks = 10;
    conf = CONFIG_INT(diet::UPDATELINKPERIOD);

    if (conf)
	new ReferenceUpdateThread(this, conf) ;
    else
	new ReferenceUpdateThread(this, 300) ;
    TRACE_TEXT(TRACE_ALL_STEPS, "Getting MAs references ... done." << std::endl);
#endif /* HAVE_MULTI_MA */

    /* num_session thread safe*/
    // NOTE: std::endl already flushes out output stream
    TRACE_TEXT(TRACE_MAIN_STEPS, std::endl
	       << "Master Agent " << this->myName << " started." << std::endl);

#if HAVE_DAGDA
    catalog = new MapDagdaCatalog();
#endif

    return 0;
} // run(char* configFileName)



/**
 * Returns the identifier of a data by agreggation of numsession and numdata
 */
char *
MasterAgentImpl::get_data_id()
{
#if ! HAVE_DAGDA
    char* id = new char[100];
    (this->num_data)++;
    sprintf(id,"id.%s.%d.%d",myName,(int)(num_session), (int)(num_data));
    return CORBA::string_dup(id);
#else /* ! HAVE_DAGDA */
#if ! HAVE_ADVANCED_UUID
    char id[100];
    (this->num_data)++;
    sprintf(id,"DAGDA://id.%s.%d.%d",myName,(int)(num_session), (int)(num_data));
    return CORBA::string_dup(id);
#else /* ! HAVE_ADVANCED_UUID */
    uuid_t uuid;
    char ID[37];
    string id("DAGDA://id-");

    uuid_generate(uuid);
    uuid_unparse(uuid, ID);
    id+=ID;
    id+="-";
    id+=myName;
    return CORBA::string_dup(id.c_str());
#endif /* ! HAVE_ADVANCED_UUID */
#endif /* ! HAVE_DAGDA */
} // get_data_id()

/****************************************************************************/
/* Available Service                                                        */
/****************************************************************************/

/**
 * Returns the list of Profile available
 */
SeqCorbaProfileDesc_t*
MasterAgentImpl::getProfiles(CORBA::Long& length)
{
    TRACE_TEXT(TRACE_ALL_STEPS,"ask for list of services" << std::endl);
    return this->AgentImpl::SrvT->getProfiles(length);
}


/****************************************************************************/
/* Submission                                                               */
/****************************************************************************/

/**
 * Invoke Loc Manager method to get data presence information (call by client)
 * When using DAGDA instead of DTM, uses the search of data on the platform.
 */
CORBA::ULong
MasterAgentImpl::dataLookUp(const char* argID){
#if ! HAVE_DAGDA
    if(locMgr->dataLookUp(strdup(argID))==0)
	return 0;
    else
	return 1;
#else /* ! HAVE_DAGDA */
    return dataManager->pfmIsDataPresent(argID);
#endif /* ! HAVE_DAGDA */
} // dataLookUp(const char* argID)

/**
 * invoke loc Manager method to get data descriptor of the data identified by argID
 * When using DAGDA, the description is obtained from DAGDA instead of DTM.
 */
corba_data_desc_t*
MasterAgentImpl::get_data_arg(const char* argID)
{
#if ! HAVE_DAGDA
    /* Memory leak ??? resp is instanciated with a new
       and forgotten on the following line... */
    corba_data_desc_t* resp = new corba_data_desc_t;
    resp = locMgr->set_data_arg(argID);
    return resp;
#else /* ! HAVE_DAGDA */
    return dataManager->pfmGetDataDesc(argID);
#endif /* ! HAVE_DAGDA */
}

/** Problem submission : remotely called by client. */
#if ! HAVE_ALTPREDICT
corba_response_t*
MasterAgentImpl::submit(const corba_pb_desc_t& pb_profile,
			CORBA::ULong maxServers)
#else /* ! HAVE_ALTPREDICT */
    corba_response_t*
    MasterAgentImpl::submit(const corba_pb_desc_t& pb_profile,
			    CORBA::ULong maxServers,
			    const char *clientHostname,
			    const char *clientLocID)
#endif /* ! HAVE_ALTPREDICT */
{
    corba_request_t   creq;
    corba_response_t* decision(0);
    char statMsg[128];
    MA_TRACE_FUNCTION(pb_profile.path <<", " << maxServers);

    /* Initialize statistics module */
    stat_init();

    try {
	/* Initialize the corba request structure */
	creq.reqID = reqIDCounter++; // thread safe
	sprintf(statMsg, "start request %ld", (unsigned long) creq.reqID);
	stat_in(this->myName,statMsg);
	creq.pb = pb_profile;
	creq.max_srv = maxServers ;
#if HAVE_ALTPREDICT
	creq.clientHostname = CORBA::string_dup(clientHostname);
	creq.clientLocationID = CORBA::string_dup(clientLocID);
#endif /* HAVE_ALTPREDICT */

#ifdef USE_LOG_SERVICE
	if (dietLogComponent) {
	    dietLogComponent->logAskForSeD(&creq);
	}
#endif /* USE_LOG_SERVICE */

	decision = submit_local(creq) ;

#ifdef HAVE_MULTI_MA
	if (decision->servers.length() == 0) {
	    sprintf(statMsg, "start floodRequest %ld",
		    (unsigned long) creq.reqID);
	    stat_in(this->myName,statMsg);

	    FloodRequest& floodRequest =
		*(new FloodRequest(MADescription(),
				   MADescription(_this(), myName),
				   creq, knownMAs)) ;

	    while((decision->servers.length() == 0) &&
		  (!floodRequest.flooded())) {
		TRACE_TEXT(TRACE_ALL_STEPS, "multi-MAs search "
			   << creq.pb.path
			   << " request (" << creq.reqID << ")" << std::endl) ;
		int flooded = floodRequest.floodNextStep() ;
		if (!flooded) {
		    bool requestAdded =
			floodRequestsList->put(floodRequest) ;
		    assert(requestAdded) ;
		    floodRequest.waitResponses() ;
		    try {
			floodRequestsList->get(creq.reqID) ;
			*decision = floodRequest.getDecision() ;
			TRACE_TEXT(TRACE_ALL_STEPS, decision->servers.length()
				   << " SeD have been found for request ("
				   << creq.reqID << ")" << std::endl) ;
		    } catch(FloodRequestNotFoundException f) {
			WARNING("Can not found the requested decision in multi-MA search");
		    }
		}
	    }
	    try {
		floodRequest.stopFlooding() ;
	    } catch (FloodRequestNotFoundException& e) {
		WARNING(e) ;
	    }
	    delete &floodRequest ;

	    sprintf(statMsg, "stop floodRequest %ld",
		    (unsigned long) creq.reqID);
	    stat_out(this->myName,statMsg);
	}
#endif /* HAVE_MULTI_MA */
    } catch(...) {
	WARNING("An exception was caught" << endl) ;
    }

#ifdef USE_LOG_SERVICE
    if (dietLogComponent) {
	dietLogComponent->logSedChosen(&creq, decision);
    }
#endif /* USE_LOG_SERVICE */

    TRACE_TEXT(TRACE_MAIN_STEPS,
	       "**************************************************"
	       << std::endl);
    sprintf(statMsg, "stop request %ld", (unsigned long) creq.reqID);
    stat_out(this->myName,statMsg);
    stat_flush();

    return decision;
}


/** Problem submission. Looking for SeDs that can resolve the
    problem in the local domain. */
corba_response_t*
MasterAgentImpl::submit_local(const corba_request_t& creq)
{
    corba_response_t* resp(0);
    Request* req(0);

    /* Initialize the request with a global scheduler */
    TRACE_TEXT(TRACE_ALL_STEPS, "Initialize the request "
	       << creq.reqID << "." << std::endl);
    /* Check that service exists */
    ServiceTable::ServiceReference_t sref;
    srvTMutex.lock();
    sref = this->SrvT->lookupService(&(creq.pb));

    if (sref == -1) { /* service does not exist */
	srvTMutex.unlock();
	/* Initialize the response */
	resp = new corba_response_t;
	resp->reqID = creq.reqID;
	resp->servers.length(0);
#if HAVE_ALTPREDICT
	resp->dataLoc.length(0);
#endif /* HAVE_ALTPREDICT */
    } else {
#if ! defined HAVE_ALT_BATCH
	CORBA::Long numProfiles;
	SeqCorbaProfileDesc_t *profiles = this->SrvT->getProfiles(numProfiles);
	assert(sref < numProfiles);
	const corba_profile_desc_t profile = (*profiles)[sref];
#else /* ! defined HAVE_ALT_BATCH */
	/* I have defined, for batch cases, ServiceTable::getProfile( index )
	   I use it here because of efficiency.
	   Can we replace previous non batch code?

	   TODO: we can only manipulate reference here... look if we can change
	   chooseGlobalScheduler() prototype */
	corba_profile_desc_t profile = this->SrvT->getProfile( sref ) ;
	/* Copy parallel flag of the client profile (reason why not const
	   anymore) */
	profile.parallel_flag = creq.pb.parallel_flag ;
#endif /* ! defined HAVE_ALT_BATCH */
	srvTMutex.unlock();
	req = new Request(&creq,
			  GlobalScheduler::chooseGlobalScheduler(&creq,
								 &profile));
	/** Forward request and schedule the responses */
	resp = findServer(req, creq.max_srv);
#if ! defined HAVE_ALT_BATCH
    delete profiles;
#endif /* ! defined HAVE_ALT_BATCH*/
    }

    resp->myID = (ChildID) - 1;

    // Constructor initializes sequences with length == 0
    if ((resp) && (resp->servers.length() != 0)) {
	resp->servers.length(MIN(resp->servers.length(),
				 static_cast<size_t>(creq.max_srv)));
	TRACE_TEXT(TRACE_ALL_STEPS, "Decision signaled." << std::endl);
    } else {
	TRACE_TEXT(TRACE_MAIN_STEPS,
		   "No server found for problem "
		   << creq.pb.path << "." << std::endl);
    }

    reqList[creq.reqID] = 0;
    delete req ;

    return resp;
} // submit_local(const corba_request_t& req, ...)


CORBA::Long
MasterAgentImpl::get_session_num()
{
    (this->num_session)++;
    return num_session;
}//get_session_num()

/**
   invoked by client : frees persistent data identified by argID, if not exists return NULL
*/
CORBA::Long
MasterAgentImpl::diet_free_pdata(const char* argID)
{
#if ! HAVE_DAGDA
    if(this->dataLookUp(ms_strdup(argID)) == 0) {
	locMgr->rm_pdata(ms_strdup(argID));
	return 1;
    } else
	return 0;
#else /* ! HAVE_DAGDA */
    if (!dataManager->pfmIsDataPresent(argID))
	return 0;
    dataManager->pfmRemData(argID);
    return 1;
#endif /* ! HAVE_DAGDA */
} //diet_free_pdata(const char* argID)


#ifdef HAVE_MULTI_MA
char* MasterAgentImpl::getBindName()
{
    return CORBA::string_dup(bindName) ;
}


/* Update MAs references */
void
MasterAgentImpl::updateRefs()
{
    //  cout << "updateRefs()" << endl ;

    MAIds.lock() ;
    MasterAgent_var ma ;
    int loopCpt = 0 ;

    for(StrList::iterator iter = MAIds.begin() ;
	iter != MAIds.end() ; ++iter) {
	if(loopCpt < maxMAlinks) {
	    TRACE_TEXT(TRACE_ALL_STEPS, "Resolving " << *iter << "...");
	    ma = bindSrv->lookup(*iter) ;
	    if(CORBA::is_nil(ma)) {
		TRACE_TEXT(TRACE_ALL_STEPS, "not found" << std::endl) ;
	    } else {
		TRACE_TEXT(TRACE_ALL_STEPS, "found" << std::endl) ;
		try {
		    bool result = ma->handShake(myName, bindName) ;
		    if (result) {
			TRACE_TEXT(TRACE_ALL_STEPS,
				   "connection accepted" << std::endl) ;
			knownMAs[*iter] = MADescription(ma, ma->getHostname()) ;
			loopCpt++ ;
		    } else {
			TRACE_TEXT(TRACE_ALL_STEPS,
				   "connection refused" << std::endl) ;
			knownMAs.erase(*iter) ;
		    }
		} catch(CORBA::SystemException& ex) {
		    TRACE_TEXT(TRACE_ALL_STEPS,
			       "obsolete reference" << std::endl) ;
		    knownMAs.erase(*iter) ;
		}
	    }
	} else {
	    knownMAs.erase(*iter) ;
	}
    }

    MAIds.unlock() ;
    logNeighbors();
  //  cout << "--updateRefs()" << std::endl ;
} // updateRefs()




/****************************************************************************/
/* MAs handshake                                                            */
/****************************************************************************/

CORBA::Boolean
MasterAgentImpl::handShake(const char* maName, const char* myName)
{
    TRACE_TEXT(TRACE_ALL_STEPS, myName
	       << " is shaking my hand ("
	       << knownMAs.size() << "/" << maxMAlinks << ")" << std::endl) ;
    MasterAgent_ptr me =
	ORBMgr::getMgr()->resolve<MasterAgent, MasterAgent_ptr>(AGENTCTXT,maName);
    /* FIXME: There is probably a cleaner way to find if to IOR are equal */
    string myior = ORBMgr::getMgr()->getIOR(_this());
    string hisior = ORBMgr::getMgr()->getIOR(me);
    if (myior==hisior) {
	TRACE_TEXT(TRACE_ALL_STEPS,
		   "I refuse to handshake with myself" << std::endl) ;
	/* we need to return now, because the knownMA locker is already
	   taken by the updateRefs function which call the handshake
	   one. */
	/*    free(myior) ;
	      free(hisior) ;*/
	return false ;
    }

    /*  free(myior) ;
	free(hisior) ;*/
    knownMAs.erase(myName) ;

    // there is to much links to accept a new one.
    if (knownMAs.size() >= static_cast<size_t>(maxMAlinks))
	return false ;

    MAIds.insert(myName) ;
    knownMAs[myName] = MADescription(me, me->getHostname()) ;

    logNeighbors();
    return true ;
} // handShake(MasterAgent_ptr me, const char* myName)

/****************************************************************************/
/*                           Flooding Algorithm                             */
/****************************************************************************/

void MasterAgentImpl::searchService(const char* predecessorStr,
				    const char* predecessorId,
				    const corba_request_t& request) {

    char statMsg[128];
    MasterAgent_ptr predecessor =
	ORBMgr::getMgr()->resolve<MasterAgent, MasterAgent_ptr>(AGENTCTXT,
								predecessorStr);
    //printTime() ;
    //fprintf(stderr, ">>>>>searchService from %s, %d, %s\n", predecessorId,  (int)request.reqID, (const char*)myName) ;
    TRACE_TEXT(TRACE_ALL_STEPS, predecessorId << " search "
	       << request.pb.path << " request (" << request.reqID << ")"
	       << std::endl) ;

    /* Initialize statistics module */
    stat_init();

    sprintf(statMsg, "start searchService %ld", (unsigned long) request.reqID);
    stat_in(this->myName,statMsg);

    reqIdList.lock() ;
    ReqIdList::iterator pos = reqIdList.find(request.reqID) ;
    bool found = (pos != reqIdList.end()) ;
    if (! found)
	reqIdList.insert(pos, request.reqID) ;
    reqIdList.unlock() ;

    if (found) {
	predecessor->alreadyContacted(request.reqID, bindName) ;
	TRACE_TEXT(TRACE_ALL_STEPS, "already contacted for request (" <<
		   request.reqID << ")" << std::endl) ;
    } else {
	FloodRequest& floodRequest =
	    *(new FloodRequest(MADescription(predecessor, predecessorId),
			       MADescription(_this(), bindName),
			       request, knownMAs)) ;

	floodRequestsList->put(floodRequest) ;

	corba_response_t* decision = submit_local(request) ;

	if (decision->servers.length() == 0) {
	    predecessor->serviceNotFound(request.reqID, bindName) ;
	    TRACE_TEXT(TRACE_ALL_STEPS, "no server for request (" <<
		       request.reqID << ")" << std::endl) ;
	} else {
	    predecessor->serviceFound(request.reqID, *decision) ;
	    TRACE_TEXT(TRACE_ALL_STEPS, decision->servers.length()
		       << " server(s) found for request (" <<
		       request.reqID << ")" << std::endl) ;
	}
    }

    TRACE_TEXT(TRACE_MAIN_STEPS,
	       "**************************************************"
	       << std::endl);
    sprintf(statMsg, "stop searchService %ld", (unsigned long) request.reqID);
    stat_out(this->myName,statMsg);
    stat_flush();
    //printf("<<<<<search service from %s\n", predecessorId) ;
} // searchService(...)


void MasterAgentImpl::stopFlooding(CORBA::Long reqId,
				   const char* senderId)
{
    //fprintf(stderr, "stopFlooding from %s, %s:%d, %s\n", senderId, (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName) ;
    try {
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId) ;
	floodRequest.stopFlooding() ;
	delete &floodRequest ;
	reqIdList.erase(reqId) ;
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e) ;
    }
}


void MasterAgentImpl::serviceNotFound(CORBA::Long reqId,
				      const char* senderId)
{
    //fprintf(stderr, "serviceNotFound from %s, %s:%d, %s\n", senderId, (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName) ;
    try {
	TRACE_TEXT(TRACE_ALL_STEPS, "service not found by " << senderId
		   << " for request (" << reqId << ")" << std::endl) ;
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId) ;
	floodRequest.addResponseNotFound() ;
	floodRequestsList->put(floodRequest) ;
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e) ;
    }
}


void MasterAgentImpl::newFlood(CORBA::Long reqId,
			       const char* senderId)
{
    //fprintf(stderr, "newFlood from %s, %s:%d, %s\n", senderId, (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName) ;
    TRACE_TEXT(TRACE_ALL_STEPS, senderId << " continue the search for "
	       << " request (" << reqId << ")" << std::endl) ;
    try {
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId);
	bool flooded = floodRequest.floodNextStep();
	floodRequestsList->put(floodRequest);
	if (flooded) {
	    floodRequest.getPredecessor()->floodedArea(reqId, bindName);
	} else {
	    floodRequest.waitResponses();
	    floodRequestsList->get(reqId);
	    try {
		corba_response_t decisions = floodRequest.getDecision();
		if(decisions.servers.length() != 0) {
		    floodRequest.getPredecessor()->serviceFound(reqId,
								decisions);
		    decisions.servers.length(0);
		} else if (floodRequest.flooded()) {
		    floodRequest.getPredecessor()->floodedArea(reqId, bindName);
		} else {
		    floodRequest.getPredecessor()->serviceNotFound(reqId,
								   bindName);
		}
	    } catch (FloodRequestNotFoundException& e) {
		WARNING(e);
	    } catch(CORBA::SystemException& ex) {
		// does nothing
	    }
	    floodRequestsList->put(floodRequest);
	}
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e);
    } catch(CORBA::SystemException& ex) {
	// does nothing
    }
}

void MasterAgentImpl::floodedArea(CORBA::Long reqId,
				  const char* senderId) {
    //fprintf(stderr, "floodedArea from %s, %s:%d, %s\n", senderId, (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName);
    TRACE_TEXT(TRACE_ALL_STEPS, "stop the flood of " << senderId
	       << " for request (" << reqId << ")" << std::endl);
    try {
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId);
	floodRequest.addResponseFloodedArea(senderId);
	floodRequestsList->put(floodRequest);
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e);
    }
}


void MasterAgentImpl::alreadyContacted(CORBA::Long reqId,
				       const char* senderId) {
    //fprintf(stderr, "alreadyContacted from %s, %s:%d, %s\n", senderId, (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName);
    TRACE_TEXT(TRACE_ALL_STEPS, "already contacted for request ("
	       << reqId << ")");
    try {
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId);
	floodRequest.addResponseAlreadyContacted(senderId);
	floodRequestsList->put(floodRequest);
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e);
    }
}


void MasterAgentImpl::serviceFound(CORBA::Long reqId,
				   const corba_response_t& decision) {
    //printTime();
    //fprintf(stderr, "%d serviceFound, %s:%d, %s\n", (int)decision.length(), (const char*)reqId.maId, (int)reqId.idNumber, (const char*)myName);
    try {
	FloodRequest& floodRequest =
	    floodRequestsList->get(reqId);
	floodRequest.addResponseServiceFound(decision);
	floodRequestsList->put(floodRequest);
    } catch (FloodRequestNotFoundException& e) {
	WARNING(e);
    }
    //printf("<<<<<%d service found\n", (int)decision.length());
}

void
MasterAgentImpl::logNeighbors() {
    char *str;
    size_t str_len = 1;

    knownMAs.lock();
    for(MasterAgentImpl::MAList::iterator iter = knownMAs.begin();
	iter != knownMAs.end(); ++iter)
	str_len += strlen(iter->first) + 1;

    str = new char[str_len];
    str[0] = 0;

    for(MasterAgentImpl::MAList::iterator iter = knownMAs.begin();
	iter != knownMAs.end(); ++iter) {
	strcat(str, iter->first);
	strcat(str, " ");
    }
    knownMAs.unlock();
    TRACE_TEXT(TRACE_MAIN_STEPS, "Multi-MAs neighbors " << str << std::endl);

#ifdef USE_LOG_SERVICE
    if (dietLogComponent) {
	dietLogComponent->logNeighbors(str);
    }
#endif /* USE_LOG_SERVICE */
}

#endif /* HAVE_MULTI_MA */

#ifdef HAVE_WORKFLOW

/**
 * Workflow submission function.
 */
wf_response_t *
MasterAgentImpl::submit_pb_set(const corba_pb_desc_seq_t& seq_pb)
{
    wf_response_t *wf_response = new wf_response_t;
    unsigned int len = seq_pb.length();
    unsigned int failureIdx;
    wf_response->wfn_seq_resp.length(0);
    corba_response_t * corba_response = 0;
    bool missingService = false;

    TRACE_TEXT(TRACE_MAIN_STEPS,
	       "The MasterAgent receives a set of "
	       << len << " problems" << std::endl);
    // LOOP for MA submissions (keeps the order of problems sequence)
    for (unsigned int ix=0; ix<len; ix++) {
	corba_response = this->submit(seq_pb[ix], 1024);
	if ((!corba_response) || (corba_response->servers.length() == 0)) {
	    missingService = true;
	    failureIdx = ix;
	    break;
	} else {
	    wf_response->wfn_seq_resp.length(ix+1);
	    wf_response->wfn_seq_resp[ix].node_id =
		CORBA::string_dup(seq_pb[ix].path);
	    wf_response->wfn_seq_resp[ix].response = *corba_response;
	}
	delete corba_response;
    }

    // Handle exception of missing service
    if (!missingService) {
	wf_response->complete = true;
    } else {
	TRACE_TEXT (TRACE_MAIN_STEPS,
		    "The problem set can't be solved (one or more services are "
		    << "missing) " << std::endl);
	wf_response->complete = false;
	wf_response->idxError = failureIdx;
    }

    return wf_response;
}
/**
 * A submission function used to submit a set of problem to the MA (OBSOLETE)
 *
 * @param pb_seq     sequence of problems
 * @param reqCount   number of requests of the client. The request number is at least
 *                   equal to sequence problem length but it can be greater if a problem
 *                   has to be executed more than one time
 * @param complete   indicates if the response is complete. The function return at the first problem
 *                   that cannot be solved
 * @param firstReqId the first request identifier to be used by the client
 * @param seqReqId   an identifier to the submission (each sequence submission
 *                   has a unique identifier)
 */
response_seq_t*
MasterAgentImpl::submit_pb_seq(const corba_pb_desc_seq_t& pb_seq,
			       CORBA::Long reqCount,
			       CORBA::Boolean& complete,
			       CORBA::Long& firstReqId,
			       CORBA::Long& seqReqId)
{
    struct timeval start, end;
    gettimeofday(&start, 0);
    static CORBA::Long mySeqReqId = 0;
    response_seq_t *response_seq = new response_seq_t;
    corba_response_t *corba_response = 0;
    complete = false;

    for (unsigned int ix=0; ix<pb_seq.length(); ix++) {
	corba_response = this->submit(pb_seq[ix], reqCount);
	if ((!corba_response) || (corba_response->servers.length() == 0)) {
	    TRACE_TEXT (TRACE_MAIN_STEPS,
			"Problem sequence can't be solved: service "
			<< pb_seq[ix].path
			<< " missing) " << std::endl);
	    return response_seq;
	} else {
	    response_seq->length(ix+1);
	    (*response_seq)[ix].problem = pb_seq[ix];
	    (*response_seq)[ix].servers = corba_response->servers;
	} // end if
    } // end for

    TRACE_TEXT (TRACE_MAIN_STEPS,
		"Problem sequence can be solved (all services available) "
		<< std::endl);
    complete = true;
    // Update request identifiers
    reqCount_mutex.lock();
    seqReqId = mySeqReqId++;
    reqIDCounter = reqIDCounter + reqCount - pb_seq.length();
    reqCount_mutex.unlock();

    gettimeofday(&end, 0);
    /*	time_t ptime = (end.tv_sec - start.tv_sec)* 1000 +
	(end.tv_usec - start.tv_usec)/1000;*/
#ifdef USE_LOG_SERVICE
    if (dietLogComponent) {
	// FIXME: update dietLogComponent with the new data structure
	// dietLogComponent->logDagSubmit(wf_response, ptime);
    }
#endif /* USE_LOG_SERVICE */
    return response_seq;
}
#endif /* HAVE_WORKFLOW */

#if HAVE_DAGDA
SeqString* MasterAgentImpl::searchData(const char* request)
{
    SeqString* ret = new SeqString();
    attributes_t attr = catalog->request(request);
    attributes_t::iterator it;
    int i=0;

    ret->length(attr.size());
    for (it=attr.begin(); it!=attr.end(); ++it)
	(*ret)[i++]=CORBA::string_dup(it->c_str());

    return ret;
}

CORBA::Long MasterAgentImpl::insertData(const char* key,
					const SeqString& values)
{
    attributes_t attr;
    if (catalog->exists(key)) return 1;

    for (unsigned int i=0; i<values.length(); ++i) {
	attr.push_back(string(values[i]));
    }
    catalog->insert(key, attr);
    return 0;
}
#endif /* HAVE_DAGDA */

MasterAgentFwdrImpl::MasterAgentFwdrImpl(Forwarder_ptr fwdr,
					 const char* objName)
{
    this->forwarder = Forwarder::_duplicate(fwdr);
    this->objName = CORBA::string_dup(objName);
}

corba_response_t* MasterAgentFwdrImpl::submit(const corba_pb_desc_t& pb_profile,
					      CORBA::ULong maxServers)
{
    std::cout << __FILE__ << ": l." << __LINE__
	      << " (" << __FUNCTION__ << ")" << std::endl;
    std::cout << "submit(pb_profile, " << maxServers << ", "
	      << objName << ")" << std::endl;
    return forwarder->submit(pb_profile, maxServers, objName);
}

CORBA::Long MasterAgentFwdrImpl::get_session_num()
{
    return forwarder->get_session_num(objName);
}

char* MasterAgentFwdrImpl::get_data_id()
{
    return forwarder->get_data_id(objName);
}

CORBA::ULong MasterAgentFwdrImpl::dataLookUp(const char* argID)
{
    return forwarder->dataLookUp(argID, objName);
}

corba_data_desc_t* MasterAgentFwdrImpl::get_data_arg(const char* argID)
{
    return forwarder->get_data_arg(argID, objName);
}

CORBA::Long MasterAgentFwdrImpl::diet_free_pdata(const char *argID)
{
    return forwarder->diet_free_pdata(argID, objName);
}

SeqCorbaProfileDesc_t* MasterAgentFwdrImpl::getProfiles(CORBA::Long& length)
{
    return forwarder->getProfiles(length, objName);
}

#ifdef HAVE_MULTI_MA
CORBA::Boolean MasterAgentFwdrImpl::handShake(const char* name,
					      const char* myName)
{
    return forwarder->handShake(name, myName, objName);
}

char* MasterAgentFwdrImpl::getBindName()
{
    return forwarder->getBindName(objName);
}

/*void MasterAgentFwdrImpl::updateRefs()
  {
  forwarder->updateRefs(objName);
  }*/

void MasterAgentFwdrImpl::searchService(const char* predecessor,
					const char* predecessorId,
					const corba_request_t& request)
{
    forwarder->searchService(predecessor, predecessorId, request, objName);
}

void MasterAgentFwdrImpl::stopFlooding(CORBA::Long reqId,
				       const char* senderId)
{
    forwarder->stopFlooding(reqId, senderId, objName);
}

void MasterAgentFwdrImpl::serviceNotFound(CORBA::Long reqId,
					  const char* senderId)
{
    forwarder->serviceNotFound(reqId, senderId, objName);
}

void MasterAgentFwdrImpl::newFlood(CORBA::Long reqId,
				   const char* senderId)
{
    forwarder->newFlood(reqId, senderId, objName);
}

void MasterAgentFwdrImpl::floodedArea(CORBA::Long reqId,
				      const char* senderId)
{
    forwarder->floodedArea(reqId, senderId, objName);
}

void MasterAgentFwdrImpl::alreadyContacted(CORBA::Long reqId,
					   const char* senderId)
{
    forwarder->alreadyContacted(reqId, senderId, objName);
}

void MasterAgentFwdrImpl::serviceFound(CORBA::Long reqId,
				       const corba_response_t& decision)
{
    forwarder->serviceFound(reqId, decision, objName);
}
#endif /* HAVE_MULTI_MA */
#ifdef HAVE_WORKFLOW
wf_response_t*
MasterAgentFwdrImpl::submit_pb_set(const corba_pb_desc_seq_t& seq_pb)
{
    return forwarder->submit_pb_set(seq_pb, objName);
}

response_seq_t*
 MasterAgentFwdrImpl::submit_pb_seq(const corba_pb_desc_seq_t& pb_seq,
				    CORBA::Long reqCount,
				    CORBA::Boolean& complete,
				    CORBA::Long& firstReqId,
				    CORBA::Long& seqReqId)
{
    return forwarder->submit_pb_seq(pb_seq, reqCount, complete,
				    firstReqId, seqReqId, objName);
}
#endif /* HAVE_WORKFLOW */
#ifdef HAVE_DAGDA
SeqString* MasterAgentFwdrImpl::searchData(const char* request)
{
    return forwarder->searchData(request, objName);
}

CORBA::Long MasterAgentFwdrImpl::insertData(const char* key,
					    const SeqString& values)
{
    return forwarder->insertData(key, values, objName);
}
#endif /* HAVE_DAGDA */


CORBA::Long
MasterAgentFwdrImpl::agentSubscribe(const char* me, const char* hostName,
				    const SeqCorbaProfileDesc_t& services)
{
    return forwarder->agentSubscribe(me, hostName, services, objName);
}

CORBA::Long
MasterAgentFwdrImpl::serverSubscribe(const char* me, const char* hostName,
#if HAVE_JXTA
				     const char* uuid,
#endif /* HAVE_JXTA */
				     const SeqCorbaProfileDesc_t& services)
{
#if HAVE_JXTA
    return forwarder->serverSubscribe(me, hostName, uuid, services, objName);
#else
    return forwarder->serverSubscribe(me, hostName, services, objName);
#endif
}

#ifdef HAVE_DYNAMICS
CORBA::Long
MasterAgentFwdrImpl::childUnsubscribe(CORBA::ULong childID,
				      const SeqCorbaProfileDesc_t& services)
{
    return forwarder->childUnsubscribe(childID, services, objName);
}

CORBA::Long MasterAgentFwdrImpl::bindParent(const char * parentName)
{
    return forwarder->bindParent(parentName, objName);
}

CORBA::Long MasterAgentFwdrImpl::disconnect()
{
    return forwarder->disconnect(objName);
}

CORBA::Long MasterAgentFwdrImpl::removeElement(bool recursive)
{
    return forwarder->removeElement(recursive, objName);
}
#endif /* HAVE_DYNAMICS */

CORBA::Long
MasterAgentFwdrImpl::addServices(CORBA::ULong myID,
				 const SeqCorbaProfileDesc_t& services)
{
    return forwarder->addServices(myID, services, objName);
}

CORBA::Long
MasterAgentFwdrImpl::childRemoveService(CORBA::ULong childID,
					const corba_profile_desc_t& profile)
{
    return forwarder->childRemoveService(childID, profile, objName);
}

#ifdef HAVE_DAGDA
char* MasterAgentFwdrImpl::getDataManager() {
    return forwarder->getDataManager(objName);
}
#endif /* HAVE_DAGDA */

void MasterAgentFwdrImpl::getResponse(const corba_response_t& resp)
{
    forwarder->getResponse(resp, objName);
}

CORBA::Long MasterAgentFwdrImpl::ping()
{
    return forwarder->ping(objName);
}

char* MasterAgentFwdrImpl::getHostname()
{
    return forwarder->getHostname(objName);
}

