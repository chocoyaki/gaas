/****************************************************************************/
/* Port adapter classes used to split or merge container content            */
/*                                                                          */
/*                                                                          */
/* Author(s):                                                               */
/* - Benjamin Isnard (benjamin.isnard@ens-lyon.fr)                          */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.24  2011/01/23 19:16:28  bdepardo
 * Removed debug messages
 *
 * Revision 1.23  2011/01/20 18:52:11  bdepardo
 * Set a pointer to NULL
 *
 * Revision 1.22  2011/01/14 01:30:56  bdepardo
 * Correct bug preventing two INOUT ports from being connected
 *
 * Revision 1.21  2010/07/20 09:20:11  bisnard
 * integration with eclipse gui and with dietForwarder
 *
 * Revision 1.20  2009/10/23 14:04:25  bisnard
 * bug corrections in FDataHandle
 *
 * Revision 1.19  2009/10/13 12:43:40  bisnard
 * removed obsolete ifdefs for DAGDA
 *
 * Revision 1.18  2009/09/25 12:39:19  bisnard
 * modified includes to reduce inter-dependencies
 *
 * Revision 1.17  2009/08/26 10:33:09  bisnard
 * implementation of workflow status & restart
 *
 * Revision 1.16  2009/07/30 09:43:09  bisnard
 * modified methods to free persistent data generated by workflow execution
 *
 * Revision 1.15  2009/07/10 12:54:54  bisnard
 * removed some debug
 * added pointer initialization
 *
 * Revision 1.14  2009/06/15 12:13:12  bisnard
 * added data type handling in WfPortAdapter
 * added new class WfValueAdapter to avoid data duplication
 *
 * Revision 1.13  2009/05/15 11:10:20  bisnard
 * release for workflow conditional structure (if)
 *
 * Revision 1.12  2009/04/17 09:02:15  bisnard
 * container empty elements (added WfVoidAdapter class)
 *
 * Revision 1.11  2009/02/06 14:54:43  bisnard
 * - setup exceptions
 * - added data type & depth check
 *
 * Revision 1.10  2008/12/02 10:14:51  bisnard
 * modified nodes links mgmt to handle inter-dags links
 *
 * Revision 1.9  2008/11/14 09:35:28  bdepardo
 * Bug correction in the multiple port adapter initialization
 *
 * Revision 1.8  2008/10/22 09:29:00  bisnard
 * replaced uint by standard type
 *
 * Revision 1.7  2008/10/14 13:31:01  bisnard
 * new class structure for dags (DagNode,DagNodePort)
 *
 * Revision 1.6  2008/10/02 09:10:51  bisnard
 * incorrect constant definition
 *
 * Revision 1.5  2008/10/02 07:35:10  bisnard
 * new constants definitions (matrix order and port type)
 *
 * Revision 1.4  2008/09/30 15:32:53  bisnard
 * - using simple port id instead of composite ones
 * - dag nodes linking refactoring
 * - prevNodes and nextNodes data structures modified
 * - prevNodes initialization by Node::setNodePredecessors
 *
 * Revision 1.3  2008/09/30 09:23:29  bisnard
 * removed diet profile initialization from DagWfParser and replaced by node methods initProfileSubmit and initProfileExec
 *
 * Revision 1.2  2008/09/19 14:01:30  bisnard
 * allow compile wf support with or without DAGDA
 *
 * Revision 1.1  2008/09/19 13:16:07  bisnard
 * New class to manage containers split/merge in workflows
 *
 */

#include <sstream>
#include "debug.hh"

// DIET core headers
extern "C" {
#include "DIET_Dagda.h"
}

// DIET workflows headers

#include "WfPortAdapter.hh"
#include "DagWfParser.hh"
#include "Dag.hh"
#include "DagNode.hh"
#include "DagNodePort.hh"
#include "EventTypes.hh"
#include "FNodePort.hh"


using namespace std;
using namespace events;

string WfMultiplePortAdapter::parLeftChar = "(";
string WfMultiplePortAdapter::parRightChar = ")";
string WfMultiplePortAdapter::separatorChar = ";";


/*****************************************************************************/
/*                        WfPortAdapter (ABSTRACT)                           */
/*****************************************************************************/

/**
 * Base descructor
 */
WfPortAdapter::~WfPortAdapter() {}

/**
 * Static factory method for adapters
 * Note: the caller is responsible for freeing the memory
 * Example of input: (nodeA#port1;nodeB#port2[0][1];#UNDEF;#VALDEB#toto#VALFIN#)
 */
WfPortAdapter*
WfPortAdapter::createAdapter(const string& strRef) {
  string::size_type refSep = strRef.find("(");
  if (refSep == string::npos) {
    string::size_type testVoid = strRef.find(WfVoidAdapter::voidRef);
    if (testVoid == string::npos) {
      string::size_type startValue = strRef.find(WfValueAdapter::valStartTag);
      if (startValue == string::npos) {
        string::size_type startID = strRef.find(WfDataIDAdapter::IDStartTag);
        if (startID == string::npos) {
          // case of reference to a dag port
          return new WfSimplePortAdapter(strRef);
        } else {
          // case of data ID
          startID += WfDataIDAdapter::IDStartTag.length();
          string::size_type endID = strRef.find(WfDataIDAdapter::IDFinishTag);
          return new WfDataIDAdapter(strRef.substr(startID, endID - startID));
        }
      } else {
        // case of data value
        startValue += WfValueAdapter::valStartTag.length();
        string::size_type endValue = strRef.find(WfValueAdapter::valFinishTag);
        return new WfValueAdapter(strRef.substr(startValue, endValue - startValue));
      }
    } else {
      // case of VOID data
      return new WfVoidAdapter();
    }
  } else {
    // case of container data
    string::size_type refSepLast = strRef.rfind(")");
    if (refSepLast == string::npos) {
      INTERNAL_ERROR("No closing bracket in " << strRef << endl, 1);
    }
    return new WfMultiplePortAdapter(strRef.substr(refSep+1, refSepLast-1));
  }
}

/*****************************************************************************/
/*                        WfSimplePortAdapter                                */
/*****************************************************************************/

/**
 * Constructor for simple port adapter
 * PARSING of a simple reference (with or without subports)
 */
WfSimplePortAdapter::WfSimplePortAdapter(const string& strRef)
  : nodePtr(NULL), portPtr(NULL) {
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating simple port adapter ref=" << strRef << endl);
  string::size_type nodeSep = strRef.find(":");
  string::size_type nodeStart = 0;
  if (nodeSep != string::npos) {
    this->dagName = strRef.substr(0, nodeSep);
    nodeStart = nodeSep + 1;
  }
  string::size_type portSep = strRef.find("#",nodeStart);
  if (portSep != string::npos) {
    this->nodeName = strRef.substr(nodeStart, portSep-nodeStart);
    string::size_type idxListLeft = strRef.find("[");
    if (idxListLeft == string::npos) {
      this->portName = strRef.substr(portSep+1);
    } else {
      this->portName = strRef.substr(portSep+1, idxListLeft-portSep-1);
      while (idxListLeft != string::npos) {
        string::size_type idxListRight = strRef.find("]",idxListLeft);
        if (idxListRight == string::npos) {
          // throw exception (brackets not closed)
        }
        unsigned int idx = atoi(strRef.substr(idxListLeft+1, idxListRight-idxListLeft-1).c_str());
        this->eltIdxList.push_back(idx);
        idxListLeft = strRef.find("[",idxListRight);
      }
    }
  } else {
    throw XMLParsingException(XMLParsingException::eINVALID_REF,
              "Invalid port reference (missing #) : " + strRef);
  }
}

WfSimplePortAdapter::WfSimplePortAdapter(WfPort * port,
                                         const string& portDagName) {
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating simple port adapter TO port "
//                               << port->getId() << endl);
  nodePtr  = port->getParent();
  portPtr  = port;
  nodeName = nodePtr->getId();
  portName = portPtr->getId();
  dagName  = portDagName;
}

WfSimplePortAdapter::WfSimplePortAdapter(WfPort* port,
                                         const list<unsigned int>& indexes,
                                         const string& portDagName) {
  nodePtr  = port->getParent();
  portPtr  = port;
  nodeName = nodePtr->getId();
  portName = portPtr->getId();
  dagName  = portDagName;
  eltIdxList = indexes;
}

WfSimplePortAdapter::~WfSimplePortAdapter() {}

string
WfSimplePortAdapter::getSourceRef() const {
  stringstream ss;
  if (!dagName.empty()) {
    ss << dagName << ":";
  }
  ss << nodeName << "#" << portName;
  for (list<unsigned int>::const_iterator idxIter = eltIdxList.begin();
       idxIter != eltIdxList.end();
       ++idxIter) {
    ss << "[" << (unsigned int) *idxIter << "]";
  }
  return ss.str();
}

void
WfSimplePortAdapter::setNodePrecedence(WfNode* node, NodeSet* nodeSet) throw (WfStructException) {
  // create the full node name (including dag prefix if needed)
  string dagPrefix;
  if (!dagName.empty()) {
    dagPrefix = dagName + ":";
  }
  // get the node pointer from the nodeSet
  nodePtr = nodeSet->getNode(dagPrefix + nodeName);
  node->addNodePredecessor(nodePtr, dagPrefix + nodePtr->getId());
}

/**
 * Initializes the connection between two WfPorts
 * This method searches the remote port then updates its own pointer
 * and calls the method WfPort::connectToPort on both sides
 * The adapterLevel parameter is used only to check depth compatibility between
 * the adapter and the linked port
 */
void
WfSimplePortAdapter::connectPorts(WfPort* port, unsigned int adapterLevel)
    throw (WfStructException)
{
  if (nodePtr == NULL) {
    INTERNAL_ERROR(__FUNCTION__ << "NULL node pointer" << endl, 1);
  }
  WfPort * linkedPort = nodePtr->getPort(portName);
  string errorMsg = "connect " + port->getCompleteId()
                       + " to " + linkedPort->getCompleteId();

  // check data type compatibility
  if (port->getBaseDataType() != linkedPort->getBaseDataType())
    throw WfStructException(WfStructException::eTYPE_MISMATCH,errorMsg);

  this->portPtr = linkedPort;       // SET the port ref FOR THE ADAPTER
  // SET the connection on my port
  if (port->getPortType() == WfPort::PORT_INOUT
      && NULL != dynamic_cast<FNodeInOutPort*>(port)) {
    dynamic_cast<FNodeInOutPort*>(port)->connectToPort(linkedPort, false);
  } else {
    port->connectToPort(linkedPort);
  }

  // SET the connection on remote port
  if (linkedPort->getPortType() == WfPort::PORT_INOUT
      && NULL != dynamic_cast<FNodeInOutPort*>(linkedPort)) {
      dynamic_cast<FNodeInOutPort*>(linkedPort)->connectToPort(port, true);
  } else {
    linkedPort->connectToPort(port);
  }

  // check data depth compatibility
  if (port->getDepth() != adapterLevel + linkedPort->getDepth() - getDepth())
    throw WfStructException(WfStructException::eDEPTH_MISMATCH,errorMsg);
}

DagNodeOutPort*
WfSimplePortAdapter::getSourcePort() const {
  DagNodeOutPort* p = dynamic_cast<DagNodeOutPort*>(portPtr);
  if (!p) {
    INTERNAL_ERROR(__FUNCTION__ << " used with adapter to incorrect port type" << endl, 1);
  }
  return p;
}

const string&
WfSimplePortAdapter::getSourceDataID() {
  if (!dataID.empty()) return dataID;
  if (getDepth() == 0)
    dataID = getSourcePort()->getDataID();
  else
    dataID = getSourcePort()->getElementDataID(eltIdxList);
  return dataID;
}

WfCst::WfDataType
WfSimplePortAdapter::getSourceDataType() {
  return getSourcePort()->getDataType(getDepth());
}

// unsigned int
// WfSimplePortAdapter::getSourceDataCardinal() {
//   return getSourcePort()->getDataIDCardinal(getSourceDataID());
// }

bool
WfSimplePortAdapter::isDataIDCreator() {
  return false;
}

void
WfSimplePortAdapter::writeDataValue(WfDataWriter* dataWriter) {
  if (getDepth() == 0)
    getSourcePort()->writeData(dataWriter);
  else
    getSourcePort()->writeDataElement(dataWriter, eltIdxList);
}

const string&
WfSimplePortAdapter::getPortName() const {
  return portName;
}

const string&
WfSimplePortAdapter::getNodeName() const {
  return nodeName;
}

const string&
WfSimplePortAdapter::getDagName() const {
  return dagName;
}

unsigned int
WfSimplePortAdapter::getDepth() const {
  return eltIdxList.size();
}

const list<unsigned int>&
WfSimplePortAdapter::getElementIndexes() {
  return eltIdxList;
}

void
WfSimplePortAdapter::freeAdapterPersistentData(MasterAgent_var& MA) {
}

/*****************************************************************************/
/*                       WfMultiplePortAdapter                               */
/*****************************************************************************/

/**
 * Constructor for multiple port adapter
 * Builds a hierarchy of adapters
 * Example of input: (nodeA#port1;nodeB#port1[0]);(nodeC#port1;#UNDEF)
 * (note that createAdapter strips the toplevel parenthesis)
 */
WfMultiplePortAdapter::WfMultiplePortAdapter(const string& strRef) {
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating multiple ports adapter ref=/" << strRef << "/" << endl);
  string::size_type refStart = 0;
  parse(strRef, refStart);
}

void WfMultiplePortAdapter::parse(const string& strRef,
                                  string::size_type& startPos) {
//   cout << "parse adapter string at position " << itoa(startPos) << endl;
  while (startPos < strRef.length()) {
    string::size_type parLeft  = strRef.find(parLeftChar,startPos);
    string::size_type parRight = strRef.find(parRightChar,startPos);
    string::size_type sepRight = strRef.find(separatorChar,startPos);
    if (parLeft < sepRight) { // multiple refs inside ( )
      startPos = parLeft+1;
      WfMultiplePortAdapter* mulAd = new WfMultiplePortAdapter();
      mulAd->parse(strRef, startPos);
      addSubAdapter(mulAd);
      // re-initialize separator position (because startPos changed)
      sepRight = strRef.find(separatorChar,startPos);
      parRight = strRef.find(parRightChar,startPos);

    } else {  // simple ref
      string::size_type refEnd = (parRight < sepRight) ? parRight-1 :
                                 (sepRight == string::npos) ? strRef.length()-1 : sepRight-1;
      WfPortAdapter* adapt = createAdapter(strRef.substr(startPos, refEnd-startPos+1));
      addSubAdapter(adapt);
    }
    // if followed by a ; => skip it and continue parsing
    if (sepRight < parRight)
      startPos = sepRight + 1;
    // in other cases i.e. ) or nothing, this is the end of the current adapter
    else {
      startPos = (parRight == string::npos) ? strRef.length()-1 : parRight + 1;
      break;
    }
  } // end while
//   cout << "end of parse - pos = " << startPos << endl;
}

WfMultiplePortAdapter::WfMultiplePortAdapter() {
//   cout << "creating empty multipleAdapter" << endl;
}

WfMultiplePortAdapter::WfMultiplePortAdapter(const WfMultiplePortAdapter& mpa) {
  // WfMultiplePortAdapter: COPY CONSTRUCTOR NOT DEFINED
}

WfMultiplePortAdapter::~WfMultiplePortAdapter() {
  // Free the adapters list
  while (! adapters.empty() ) {
    WfPortAdapter * p = adapters.front();
    adapters.pop_front();
    delete p;
  }
}

void
WfMultiplePortAdapter::addSubAdapter(WfPortAdapter* subAdapter) {
//   TRACE_TEXT (TRACE_ALL_STEPS,"Adding child adapter to multiple adapter" << endl);
  adapters.push_back(subAdapter);
}

void
WfMultiplePortAdapter::setNodePrecedence(WfNode* node, NodeSet* nodeSet)
    throw (WfStructException)
{
  for (list<WfPortAdapter*>::iterator iter = adapters.begin();
       iter != adapters.end();
       ++iter) {
    (*iter)->setNodePrecedence(node, nodeSet);
  }
}

void
WfMultiplePortAdapter::connectPorts(WfPort* port, unsigned int adapterLevel)
    throw (WfStructException)
{
  for (list<WfPortAdapter*>::iterator iter = adapters.begin();
       iter != adapters.end();
       ++iter) {
    (*iter)->connectPorts(port, adapterLevel+1);
  }
}

string WfMultiplePortAdapter::errorID = string("ID_Error");

string
WfMultiplePortAdapter::getSourceRef() const {
  string s = "(";
  list<WfPortAdapter*>::const_iterator adaptIter = adapters.begin();
  while (adaptIter != adapters.end()) {
    s += ((WfPortAdapter*) *adaptIter)->getSourceRef();
    if (++adaptIter != adapters.end())
      s += ";";
  }
  s += ")";
  return s;
}

const string&
WfMultiplePortAdapter::getSourceDataID() {
  if (!containerID.empty()) return containerID;
  // First check if all adapters have either their ID defined or are VOID
  // (will throw exception if one is not defined)
  for (list<WfPortAdapter*>::iterator iter = adapters.begin();
         iter != adapters.end();
         ++iter) {
     try {
      (*iter)->getSourceDataID();
     } catch (WfDataException& e) {
       if (e.Type() != WfDataException::eVOID_DATA)
         throw;
     }
  }
  // If ok then create container to merge all adapters
  char* idCont;
  TRACE_TEXT (TRACE_ALL_STEPS,"## Creating container to merge ports" << endl);
  dagda_create_container(&idCont);
  int ix=0;
  for (list<WfPortAdapter*>::iterator iter = adapters.begin();
       iter != adapters.end();
       ++iter) {
     try {

      const string& idElt = (*iter)->getSourceDataID();
      TRACE_TEXT(TRACE_ALL_STEPS, "## merging " << idElt << " into " << idCont << endl);
      dagda_add_container_element(idCont,idElt.c_str(),ix++);

     } catch (WfDataException& e) {
        if (e.Type() == WfDataException::eVOID_DATA) {
          TRACE_TEXT(TRACE_ALL_STEPS, "## merging NULL elt into " << idCont << endl);
          dagda_add_container_null_element(idCont, ix++);
        } else throw;
     }
  }
  containerID = idCont;
  TRACE_TEXT (TRACE_ALL_STEPS,"## End of merge ports" << endl);
  return containerID;
}

WfCst::WfDataType
WfMultiplePortAdapter::getSourceDataType() {
  return WfCst::TYPE_CONTAINER;
}

// unsigned int
// WfMultiplePortAdapter::getSourceDataCardinal() {
//   getSourceDataID(); // to initialize data if not already done
//   return adapters.size();
// }

bool
WfMultiplePortAdapter::isDataIDCreator() {
  return (!containerID.empty());
}

void
WfMultiplePortAdapter::writeDataValue(WfDataWriter* dataWriter) {
  dataWriter->startContainer();
  for (list<WfPortAdapter*>::const_iterator adaptIter = adapters.begin();
       adaptIter != adapters.end();
       ++adaptIter) {
     ((WfPortAdapter*) *adaptIter)->writeDataValue(dataWriter);
  }
  dataWriter->endContainer();
}

void
WfMultiplePortAdapter::freeAdapterPersistentData(MasterAgent_var& MA) {
  for (list<WfPortAdapter*>::const_iterator adaptIter = adapters.begin();
       adaptIter != adapters.end();
       ++adaptIter) {
     ((WfPortAdapter*) *adaptIter)->freeAdapterPersistentData(MA);
  }
  if (!containerID.empty()) {
    // This class of adapter is always the owner of its dataID
    TRACE_TEXT (TRACE_ALL_STEPS, "Deleting persistent container: " << containerID << endl);
    char *dataId = const_cast<char*>(containerID.c_str());
    if (MA->diet_free_pdata(dataId)==0) {
      WARNING("Could not delete persistent data: " << dataId << endl);
    }
  }
}

/*****************************************************************************/
/*                            WfVoidAdapter                                  */
/*****************************************************************************/

WfVoidAdapter::WfVoidAdapter() {
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating VOID adapter" << endl);
}

WfVoidAdapter::~WfVoidAdapter() {}

string WfVoidAdapter::voidRef = string("#UNDEF");

void
WfVoidAdapter::setNodePrecedence(WfNode* node, NodeSet* nodeSet)
throw (WfStructException) {
}

void
WfVoidAdapter::connectPorts(WfPort* port, unsigned int adapterLevel)
throw (WfStructException) {
}

string
WfVoidAdapter::getSourceRef() const {
  return voidRef;
}

const string&
WfVoidAdapter::getSourceDataID() {
  throw WfDataException(WfDataException::eVOID_DATA,"");
}

WfCst::WfDataType
WfVoidAdapter::getSourceDataType() {
  throw WfDataException(WfDataException::eVOID_DATA,"");
}

// unsigned int
// WfVoidAdapter::getSourceDataCardinal() {
//   return 1;
// }

bool
WfVoidAdapter::isDataIDCreator() {
  return false;
}

void
WfVoidAdapter::writeDataValue(WfDataWriter* dataWriter) {
  dataWriter->voidElement();
}

void
WfVoidAdapter::freeAdapterPersistentData(MasterAgent_var& MA) {
}

/*****************************************************************************/
/*                          WfValueAdapter                                   */
/*****************************************************************************/

string WfValueAdapter::valStartTag = string("#VALDEB#");
string WfValueAdapter::valFinishTag = string("#VALFIN#");

WfValueAdapter::WfValueAdapter(const string& value)
  : myValue(value), myDataType(WfCst::TYPE_UNKNOWN),
  cx(NULL), sx(NULL), ix(NULL), lx(NULL), fx(NULL), dx(NULL), str(NULL)
{
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating VALUE adapter value=/"
//                                << value << "/" << endl);
}

WfValueAdapter::WfValueAdapter(WfCst::WfDataType valueType, const string& value)
  : myValue(value), myDataType(valueType),
  cx(NULL), sx(NULL), ix(NULL), lx(NULL), fx(NULL), dx(NULL), str(NULL)
{
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating VALUE adapter (TYPE=" << valueType
//                                << ") value=/" << value << "/" << endl);
}

WfValueAdapter::~WfValueAdapter() {
  if (cx) delete cx;
  if (sx) delete sx;
  if (ix) delete ix;
  if (lx) delete lx;
  if (fx) delete fx;
  if (dx) delete dx;
  if (str) delete str;
}

void
WfValueAdapter::setNodePrecedence(WfNode* node, NodeSet* nodeSet)
throw (WfStructException) {
}

void
WfValueAdapter::connectPorts(WfPort* port, unsigned int adapterLevel)
throw (WfStructException) {
}

string
WfValueAdapter::getSourceRef() const {
  return valStartTag + myValue + valFinishTag;
}

const string&
WfValueAdapter::getSourceDataID() {
  if (!myDataID.empty()) return myDataID;
  char *valID = NULL;
  char **valIDPtr = &valID;
  string errorMsg = "DAGDA failed to upload data to the platform (value '" + myValue + "')";
  try {
    switch (myDataType) {
      case WfCst::TYPE_CHAR:
        dagda_put_scalar(newChar(), DIET_CHAR, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_SHORT:
        dagda_put_scalar(newShort(), DIET_SHORT, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_INT:
        dagda_put_scalar(newInt(), DIET_INT, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_LONGINT:
        dagda_put_scalar(newLong(), DIET_LONGINT, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_FLOAT:
        dagda_put_scalar(newFloat(), DIET_FLOAT, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_DOUBLE:
        dagda_put_scalar(newDouble(), DIET_DOUBLE, DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_PARAMSTRING:
        dagda_put_paramstring(newString(), DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_STRING:
        dagda_put_string(newString(), DIET_PERSISTENT, valIDPtr);
        break;
      case WfCst::TYPE_FILE:
        dagda_put_file(newFile(), DIET_PERSISTENT, valIDPtr);
        break;
      default:
        throw WfDataException(WfDataException::eWRONGTYPE,
                            "Cannot initialize data due to unknown type in value adapter");
    } // end (switch)
  } catch (Dagda::ReadError& ex) {
    errorMsg += "(Read Error)";
    throw WfDataException(WfDataException::eREADFILERROR, errorMsg);
  } catch (...) {
    errorMsg += "(Dagda Exception)";
    throw WfDataException(WfDataException::eINVALID_VALUE, errorMsg);
  }
  myDataID = valID;

  return myDataID;
}

WfCst::WfDataType
WfValueAdapter::getSourceDataType() {
  return myDataType;
}

// unsigned int
// WfValueAdapter::getSourceDataCardinal() {
//   WARNING("Cannot get cardinal of a WfValueAdapter");
//   return 0;
// }

bool
WfValueAdapter::isDataIDCreator() {
  return (!myDataID.empty());
}

void
WfValueAdapter::writeDataValue(WfDataWriter* dataWriter) {
  dataWriter->itemValue(myValue);
}

void
WfValueAdapter::freeAdapterPersistentData(MasterAgent_var& MA) {
  // This class of adapter is always the owner of its dataID because
  // the dataID can be provided in the constructor
  if (isDataIDCreator()) {
    TRACE_TEXT (TRACE_ALL_STEPS, "Deleting persistent data (value adapter): "
                                 << myDataID << endl);
    char *dataId = const_cast<char*>(myDataID.c_str());
    if (MA->diet_free_pdata(dataId)==0) {
      WARNING("Could not delete persistent data: " << dataId << endl);
    }
  }
}

char *
WfValueAdapter::newChar() {
    cx = new char;
    *cx = myValue.c_str()[0];
  return cx;
}

short *
WfValueAdapter::newShort() {
  sx = new short;
  *sx = atoi(myValue.c_str());
  return sx;
}

int *
WfValueAdapter::newInt() {
  ix = new int;
  *ix = atoi(myValue.c_str());
  return ix;
}

long *
WfValueAdapter::newLong() {
  lx = new long;
  *lx = atoi(myValue.c_str());
  return lx;
}

char *
WfValueAdapter::newString() {
  str = new char[myValue.size()+1];
  strcpy(str, myValue.c_str());
  return str;
}

char *
WfValueAdapter::newFile() {
  str = new char[myValue.size()+1];
  strcpy(str, myValue.c_str());
  return str;
}

float *
WfValueAdapter::newFloat() {
  fx = new float;
  *fx = (float) atof(myValue.c_str());
  return fx;
}

double *
WfValueAdapter::newDouble() {
  dx = new double;
  *dx = atof(myValue.c_str());
  return dx;
}

/*****************************************************************************/
/*                         WfDataIDAdapter                                   */
/*****************************************************************************/

string WfDataIDAdapter::IDStartTag = string("#IDDEB#");
string WfDataIDAdapter::IDFinishTag = string("#IDFIN#");
map<string, vector<string> >	WfDataIDAdapter::myCache;

WfDataIDAdapter::WfDataIDAdapter(WfCst::WfDataType dataType,
                                 unsigned int dataDepth,
                                 const string& dataID)
  : myDataID(dataID), myDataType(dataType), myDepth(dataDepth)
{
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating DataID adapter (TYPE=" << dataType
//                               << ") dataID=/" << dataID << "/" << endl);
  if (dataID.empty()) {
    WARNING("Creating WfDataIDAdapter with empty data ID");
  }
}

WfDataIDAdapter::WfDataIDAdapter(const string& dataID)
  : myDataID(dataID), myDataType(WfCst::TYPE_UNKNOWN), myDepth(0)
{
//   TRACE_TEXT (TRACE_ALL_STEPS,"Creating DataID adapter dataID=/"
//                                << dataID << "/" << endl);
  if (dataID.empty()) {
    WARNING("Creating WfDataIDAdapter with empty data ID");
  }
}

WfDataIDAdapter::~WfDataIDAdapter() {}

void
WfDataIDAdapter::setNodePrecedence(WfNode* node, NodeSet* nodeSet)
throw (WfStructException) {
}

void
WfDataIDAdapter::connectPorts(WfPort* port, unsigned int adapterLevel)
throw (WfStructException) {
}

string
WfDataIDAdapter::getSourceRef() const {
  return IDStartTag + myDataID + IDFinishTag;
}

const string&
WfDataIDAdapter::getSourceDataID() {
  return myDataID;
}

WfCst::WfDataType
WfDataIDAdapter::getSourceDataType() {
  return myDataType;
}

void 
WfDataIDAdapter::getElements(vector< string >& vectID)
{
  if (myDataID.empty()) return;
//     TRACE_TEXT(TRACE_ALL_STEPS,"Get elements of container with ID : " << myDataID << endl);
  map<string, vector<string> >::const_iterator cacheIter = myCache.find(myDataID);
  if (cacheIter != myCache.end()) {
    vectID = cacheIter->second;
  } else {
    diet_container_t *content = new diet_container_t;
    content->size = 0;
    try {
      dagda_get_container(myDataID.c_str());
    } catch (...) {
      string errorMsg = "container ID '" + myDataID + "' : not found or invalid type";
      throw WfDataException(WfDataException::eNOTFOUND, errorMsg);
    }
    if (dagda_get_container_elements(myDataID.c_str(), content)) {
      string errorMsg = "container ID '" + myDataID + "' : cannot get container elements";
      throw WfDataException(WfDataException::eINVALID_CONTAINER, errorMsg);
    }
    if (content->size != vectID.size()) {
      vectID.resize(content->size);
    }
    string eltIdsMsg = "";
    for (unsigned int i = 0; i<content->size; ++i) {
      if (content->elt_ids[i] != NULL) {
	vectID[i] = content->elt_ids[i];
	eltIdsMsg += vectID[i];
      } else {
	eltIdsMsg += WfVoidAdapter::voidRef;
      }
      if (i != content->size-1) eltIdsMsg += ";";
    }
    sendEventFrom<WfDataIDAdapter, WfDataIDAdapter::ELTIDLIST>(this,
		"Container elements", eltIdsMsg, EventBase::INFO);
    free( content->elt_ids );
    delete content;
    
    // update cache
    myCache[myDataID] = vectID;
  }
}

string 
WfDataIDAdapter::getDataID() const
{
  return myDataID;
}

string WfDataIDAdapter::toString() const
{
  return "Adapter ID=" + myDataID;
}

bool
WfDataIDAdapter::isDataIDCreator() {
  return false;
}

void
WfDataIDAdapter::writeDataValue(WfDataWriter* dataWriter) {
  if (myDataID.empty()) {
    getSourceDataID();
  }
  getAndWriteData(dataWriter, myDataID, myDataType, myDepth);
}

// static & recursive
void
WfDataIDAdapter::getAndWriteData(WfDataWriter* dataWriter,
                                 const string& dataID,
                                 WfCst::WfDataType  dataType,
                                 unsigned int dataDepth) {
  if (dataID.empty()) {
    dataWriter->voidElement();
    return;
  }
  try {
    if (dataDepth > 0) {
      dataWriter->startContainer();
      WfDataIDAdapter	adapter(dataID);
      vector<string> 	vectID;
      adapter.getElements(vectID);
      
      for (vector<string>::iterator eltIter = vectID.begin();
	   eltIter != vectID.end();
	   ++eltIter) {
        if ((*eltIter).empty())
          dataWriter->voidElement();
	else
          getAndWriteData(dataWriter, *eltIter, dataType, dataDepth-1);
      } // end for

      dataWriter->endContainer();

    } else if (dataType == WfCst::TYPE_DOUBLE) {
      double * value;
      dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_INT) {
      int *value = NULL;
      int re;
      re = dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_LONGINT) {
      long *value;
      dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_FLOAT) {
      float *value;
      dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_CHAR) {
      char *value;
      dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_SHORT) {
      short *value;
      dagda_get_scalar(dataID.c_str(),&value,NULL);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_PARAMSTRING) {
      char *value;
      dagda_get_paramstring(dataID.c_str(),&value);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_STRING) {
      char *value;
      dagda_get_string(dataID.c_str(),&value);
      dataWriter->itemValue(value, (WfCst::WfDataType) dataType);
    } else if (dataType == WfCst::TYPE_FILE) {
      char *path;
      dagda_get_file(dataID.c_str(),&path);
      dataWriter->itemValue(path, (WfCst::WfDataType) dataType);
    }
  } catch (Dagda::DataNotFound& e) {
    string errorMsg = "Data ID = " + string(dataID.c_str());
    throw WfDataException(WfDataException::eNOTFOUND, errorMsg);
  } catch (Dagda::ReadError& e) {
    string errorMsg = "Data ID = " + string(dataID.c_str());
    throw WfDataException(WfDataException::eREADFILERROR, errorMsg);
  }
}

void
WfDataIDAdapter::freeAdapterPersistentData(MasterAgent_var& MA) {
}


