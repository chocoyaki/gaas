/****************************************************************************/
/* The class representing the nodes of a functional workflow                */
/*                                                                          */
/* Author(s):                                                               */
/* - Benjamin ISNARD (benjamin.isnard@ens-lyon.fr)                          */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.25  2010/08/27 13:23:07  bisnard
 * 'fixed segfault when using empty constant values'
 *
 * Revision 1.24  2010/08/26 07:48:39  bisnard
 * added check for non-connected input ports
 *
 * Revision 1.23  2010/07/20 09:20:11  bisnard
 * integration with eclipse gui and with dietForwarder
 *
 * Revision 1.22  2009/10/23 13:59:25  bisnard
 * replaced \n by std::endl
 *
 * Revision 1.21  2009/10/02 07:44:56  bisnard
 * new wf data operators MATCH & N-CROSS
 *
 * Revision 1.20  2009/09/25 12:49:45  bisnard
 * handle user data tags
 *
 * Revision 1.19  2009/08/26 10:33:09  bisnard
 * implementation of workflow status & restart
 *
 * Revision 1.18  2009/07/30 09:43:09  bisnard
 * modified methods to free persistent data generated by workflow execution
 *
 * Revision 1.17  2009/07/23 12:31:04  bisnard
 * new method finalize() for functional wf nodes
 * removed const on currDataLine parameter for instance creation
 *
 * Revision 1.16  2009/07/10 12:55:59  bisnard
 * implemented while loop workflow node
 *
 * Revision 1.15  2009/07/07 09:03:22  bisnard
 * changes for sub-workflows (FWorkflow class now inherits from FProcNode)
 *
 * Revision 1.14  2009/06/15 12:11:12  bisnard
 * use new XML Parser (SAX) for data source file
 * use new class WfValueAdapter to avoid data duplication
 * use new method FNodeOutPort::storeData
 * changed method to compute total nb of data items
 *
 * Revision 1.13  2009/05/27 08:49:43  bisnard
 * - modified condition output: new IF_THEN and IF_ELSE port types
 * - implemented MERGE and FILTER workflow nodes
 *
 * Revision 1.12  2009/05/15 11:10:20  bisnard
 * release for workflow conditional structure (if)
 *
 * Revision 1.11  2009/04/17 09:04:07  bisnard
 * initial version for conditional nodes in functional workflows
 *
 * Revision 1.10  2009/04/09 09:56:20  bisnard
 * refactoring due to new class FActivityNode
 *
 * Revision 1.9  2009/04/08 09:34:56  bisnard
 * pending nodes mgmt moved to FWorkflow class
 * FWorkflow and FNode state graph revisited
 * FNodePort instanciation refactoring
 *
 * Revision 1.8  2009/02/24 14:01:05  bisnard
 * added dynamic parameter mgmt for wf processors
 *
 * Revision 1.7  2009/02/20 10:23:54  bisnard
 * use estimation class to reduce the nb of submit requests
 *
 * Revision 1.6  2009/02/06 14:55:08  bisnard
 * setup exceptions
 *
 * Revision 1.5  2009/01/16 16:31:54  bisnard
 * added option to specify data source file name
 *
 * Revision 1.4  2009/01/16 13:54:50  bisnard
 * new version of the dag instanciator with iteration strategies for nodes with multiple input ports
 *
 * Revision 1.3  2008/12/09 12:15:59  bisnard
 * pending instanciation handling (uses dag outputs for instanciation
 * of a functional wf)
 *
 * Revision 1.2  2008/12/02 10:09:36  bisnard
 * added instanciation methods
 *
 * Revision 1.1  2008/10/20 08:09:58  bisnard
 * new classes for functional workflows
 *
 */

#include <string>
#include "debug.hh"
#include "FNode.hh"
#include "FWorkflow.hh"
#include "Dag.hh"
#include "DagNodePort.hh"
#include "DagWfParser.hh"
#include "EventTypes.hh"

using namespace std;
using namespace events;

FNode::FNode(FWorkflow* wf, const string& id, nodeInstStatus_t initStatus)
  : WfNode(id), wf(wf), myStatus(initStatus) {}

FNode::~FNode() {
  TRACE_TEXT (TRACE_ALL_STEPS,"~FNode() " << getId() << " destructor ..." <<  endl);
}

FWorkflow *
FNode::getWorkflow() const {
  return wf;
}

FWorkflow*
FNode::getRootWorkflow() const
{
  if (wf == NULL) return NULL;
  return wf->getRootWorkflow();
}

const string&
FNode::getDefaultPortName() const {
  INTERNAL_ERROR("FNode::getDefaultPortName not defined for this class",1);
}

/* protected */
void
FNode::setStatusReady() {
  if (!instanciationOnHold())
    myStatus = N_INSTANC_READY;
}

bool
FNode::instanciationReady() {
  return (myStatus == N_INSTANC_READY);
}

bool
FNode::instanciationPending() {
  return (myStatus == N_INSTANC_PENDING);
}

bool
FNode::instanciationOnHold() {
  return (myStatus == N_INSTANC_ONHOLD);
}

bool
FNode::instanciationCompleted() {
  return (myStatus == N_INSTANC_END);
}

bool
FNode::instanciationStopped() {
  return (myStatus == N_INSTANC_STOPPED);
}

void
FNode::stopInstanciation() {
  myStatus = N_INSTANC_STOPPED;
}

void
FNode::setInstanciationCompleted() {
  myStatus = N_INSTANC_END;
}

void
FNode::resumeInstanciation() {
  if (!instanciationCompleted() && !instanciationStopped()) {
    myStatus = N_INSTANC_READY;
    if (wf) wf->resumeInstanciation();
  }
}

WfPort *
FNode::newPort(string portId,
               unsigned int ind,
               WfPort::WfPortType portType,
               WfCst::WfDataType dataType,
               unsigned int depth) throw (WfStructException) {
  WfPort * p = NULL;
  switch (portType) {
  case WfPort::PORT_PARAM:
    p = new FNodeParamPort(this, portId, dataType, ind);
    break;
  case WfPort::PORT_IN:
    p = new FNodeInPort(this, portId, portType, dataType, depth, ind);
    break;
  case WfPort::PORT_INOUT:
    p = new FNodeInOutPort(this, portId, dataType, depth, ind);
    break;
  case WfPort::PORT_OUT:
    p = new FNodeOutPort(this, portId, portType, dataType, depth, ind);
    break;
  default:
    INTERNAL_ERROR("Invalid port type for FNode port",1);
  }
  return addPort(portId, p);
}

void
FNode::connectNodePorts() throw (WfStructException) {
  TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Connecting ports" << endl);
  for (map<string, WfPort*>::iterator p = ports.begin();
       p != ports.end();
       ++p) {
    try {
      ((WfPort*)(p->second))->connectPorts();
    } catch (WfStructException& e) {
      // depth mismatch is ok for functional nodes connections
      if (e.Type() != WfStructException::eDEPTH_MISMATCH)
        throw;
    }
  }
}

void
FNode::connectToWfPort(FNodePort* port) {}

void
FNode::initialize() {
  for (map<string, WfPort*>::iterator portIter = ports.begin();
       portIter != ports.end();
       ++portIter) {
    WfPort* port = (WfPort*) portIter->second;
    if (port->isInput() && !port->isConnected()) {
      WARNING("Input port '" << port->getCompleteId() << "' is not connected to a source");
    }
  }
}

void
FNode::finalize() {
  // Check if output ports have sent zero items
  // and if yes it updates the cardinal of connected ports
  // (this happens for ex to sources without data or to the output of a filter
  // node)
  for (map<string,WfPort*>::iterator portIter = ports.begin();
       portIter != ports.end();
       ++portIter) {
    WfPort* port = (WfPort*) portIter->second;
    if (port->isOutput()) {
      FNodeOutPort* outPort = dynamic_cast<FNodeOutPort*>(port);
      if (!outPort) {
        INTERNAL_ERROR("FNode Output port cannot be casted correctly",1);
      }
      outPort->checkIfEmptyOutput();
    }
  }
}

void
FNode::freeNodePersistentData(MasterAgent_var& MA) {
  // LOOP for each out port
  for (map<string,WfPort*>::iterator portIter = ports.begin();
       portIter != ports.end();
       ++portIter) {
    WfPort* port = (WfPort*) portIter->second;
    if (port->isOutput()) {
      FNodeOutPort* outPort = dynamic_cast<FNodeOutPort*>(port);
      outPort->freePersistentData(MA);
    }
  }
}

string
FNode::traceId() {
  return "["+myId+"]: ";
}

string FNode::toString() const
{
  return myId;
}


/*****************************************************************************/
/*                           FConstantNode                                   */
/*****************************************************************************/
string FConstantNode::outPortName("out");

const string&
FConstantNode::getDefaultPortName() const {
  return outPortName;
}

FConstantNode::FConstantNode(FWorkflow* wf, const string& id,
                             WfCst::WfDataType type)
  : FNode(wf, id, N_INSTANC_READY), myDH(NULL) {
  WfPort* outPort = this->newPort(outPortName,0,WfPort::PORT_OUT,type,0);
  myOutPort = dynamic_cast<FNodeOutPort*>(outPort);
}

FConstantNode::~FConstantNode() {
  // out port is deleted in ~WfNode()
}

void
FConstantNode::setValue(const string& strVal) {
  myValue = strVal;
}

void
FConstantNode::setDataID(const string& dataID) {
  myDataID = dataID;
}

void
FConstantNode::initialize() {
  FDataTag singleTag(0,true);
  // use data ID if available (value is not used)
  if (!myDataID.empty()) {
    TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Initialize constant (ID=/"
                << myDataID << "/)" << endl);
    myDH = new FDataHandle(singleTag, myOutPort->getBaseDataType(), 0, myDataID);

  } else {
    TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Initialize constant (value=/"
                << myValue << "/)" << endl);
    myDH = new FDataHandle(singleTag, myOutPort->getBaseDataType(), myValue);
    myDH->downloadDataID();  // add data to the platform dataMgr
  }
  myOutPort->setAsConstant(myDH);
}

void
FConstantNode::instanciate(Dag* dag) {
  myStatus = N_INSTANC_END;
}

/*****************************************************************************/
/*                            FSourceNode                                    */
/*****************************************************************************/
string FSourceNode::outPortName("out");

FSourceNode::FSourceNode(FWorkflow* wf,
                         const string& id,
                         WfCst::WfDataType type)
  : FNode(wf, id, N_INSTANC_READY), myParser(NULL), isConnected(false) {
  WfPort * outPort = this->newPort(outPortName,0,WfPort::PORT_OUT,type,0);
  myOutPort = dynamic_cast<FNodeOutPort*>(outPort);
  myParser = new DataSourceParser(this);
}

FSourceNode::~FSourceNode() {
  // out port is deleted in ~WfNode()
  delete myParser;
}

const string&
FSourceNode::getDefaultPortName() const {
  return outPortName;
}

WfCst::WfDataType
FSourceNode::getDataType() const {
  return myOutPort->getBaseDataType();
}

unsigned int
FSourceNode::getDepth() const {
  return myOutPort->getDepth();
}

void
FSourceNode::connectToWfPort(FNodePort* port) {
  FNodeInPort*  inPort = dynamic_cast<FNodeInPort*>(port);
  if (inPort) {
    myConnectedPort = inPort;
    isConnected = true;
  } else throw WfStructException(WfStructException::eOTHER,
                                 "source connected to invalid port");
}

bool
FSourceNode::isConnectedToWfPort() {
  return isConnected;
}

void
FSourceNode::instanciate(Dag* dag) {
  TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Instanciate source" << endl);
  if (!isConnected) {
    myParser->parseXml(wf->getDataSrcXmlFile());
    myOutPort->uploadAllData(dag->getExecutionAgent());
    myOutPort->updateAllDataCardinal();
    myOutPort->sendAllData();
    // check if empty
    if (myOutPort->getBufferRootDH()->isEmpty()) {
      WARNING("Workflow source '" << getId() << "' contains no data" << endl);
    }
    // instanciation is completed when file has been read
    myStatus = N_INSTANC_END;
    // send event containing the serialized data tree
    ostringstream dataTree;
    myOutPort->writeAllDataAsXML(dataTree);
    sendEventFrom<FSourceNode, FSourceNode::DATATREE>(this, "data tree", dataTree.str(), EventBase::INFO);

  } else {
    // do nothing
  }
  TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Instanciate source completed" << endl);
}

void
FSourceNode::createInstance(const FDataTag& currTag,
                            vector<FDataHandle*>& currDataLine) {
  if (isConnected) {
    FDataHandle* inDH = currDataLine[myConnectedPort->getIndex()];
    FDataHandle* outDH = new FDataHandle(*inDH);
    myOutPort->storeData(outDH);
    myOutPort->sendData(outDH);
  }
}

void
FSourceNode::toXML(ostream& output) {
  output << "<source name=\"" << this->getId() << "\">" << endl;
  myOutPort->writeAllDataAsXML(output);
  output << "</source>" << endl;
}

FDataHandle*
FSourceNode::createData( const FDataTag& tag ) {
  return new FDataHandle(tag, getDataType(), 0);
}

FDataHandle*
FSourceNode::createList( const FDataTag& tag ) {
  // depth may be wrong but it will be updated at the end by
  // updateAllDataCardinal on the whole data tree
  return new FDataHandle(tag, getDataType(), 1);
}

void
FSourceNode::setDataValue( FDataHandle* DH, const string& value) {
  DH->setValue(getDataType(),value);
}

void
FSourceNode::setDataID( FDataHandle* DH, const string& dataID) {
  DH->setDataID(dataID);
}

void
FSourceNode::setDataProperty( FDataHandle* DH,
                              const string& propKey,
                              const string& propValue ) {
  DH->addProperty(propKey, propValue);
}

void
FSourceNode::insertData( FDataHandle* newDH ) {
  try {
    myOutPort->storeData(newDH);
  } catch (WfDataHandleException& e) {
    WARNING(e.ErrorMsg());
  }
}

/*****************************************************************************/
/*                             FSinkNode                                     */
/*****************************************************************************/

string FSinkNode::inPortName("in");

FSinkNode::FSinkNode(FWorkflow* wf,
                     const string& id,
                     WfCst::WfDataType type,
                     unsigned int depth)
  : FNode(wf, id, N_INSTANC_READY), isConnected(false), myIterator(NULL) {
  WfPort * inPort = this->newPort(inPortName,0,WfPort::PORT_IN,type,depth);
  myInPort = dynamic_cast<FNodeInPort*>(inPort);
  WfPort * outPort = this->newPort("out",0,WfPort::PORT_OUT,type,depth);
  myOutPort = dynamic_cast<FNodeOutPort*>(outPort);
  myIterator = new PortInputIterator(myInPort);
}

FSinkNode::~FSinkNode() {
  // ports are deleted in ~WfNode()
}

const string&
FSinkNode::getDefaultPortName() const {
  return inPortName;
}

void
FSinkNode::connectToWfPort(FNodePort* port) {
  FNodeOutPort*  outPort = dynamic_cast<FNodeOutPort*>(port);
  if (outPort) {
    myConnectedPort = outPort;
    isConnected = true;
  } else throw WfStructException(WfStructException::eOTHER,
                                 "sink connected to invalid port");
}

bool
FSinkNode::isConnectedToWfPort() {
  return isConnected;
}

void
FSinkNode::instanciate(Dag* dag) {
  // data items will be sent either to my own buffer (if sink is within the main
  // workflow) or to my parent workflow's out port (if sink is in a sub-wf)
  FNodeOutPort* outPort = isConnected ? myConnectedPort : myOutPort;
  // use a basic port iterator to retrieve items from the input port
  vector<FDataHandle*>* DL = new vector<FDataHandle*>(1, (FDataHandle*) NULL);
  myIterator->begin();
  while (!myIterator->isAtEnd()) {
    FDataTag currTag = myIterator->getCurrentItem(*DL);
    myIterator->removeItem();
    FDataHandle* inDH = DL->front();
    if (inDH == NULL) {
      INTERNAL_ERROR("NULL data handle provided to sink",1);
    }
    FDataHandle* outDH = new FDataHandle(*inDH);
    outPort->storeData(outDH);
    outPort->sendData(outDH);
  }
  if (myIterator->isDone()) {
    TRACE_TEXT (TRACE_ALL_STEPS, traceId() <<  "ALL INPUTS PROCESSED" << endl);
    myStatus = N_INSTANC_END;
  }
}

void
FSinkNode::finalize() { }

void
FSinkNode::downloadResults() {
  myOutPort->downloadAllData();
  string rootDataID = myOutPort->getBufferContainerID();
  sendEventFrom<FSinkNode, FSinkNode::DATAID>(this, "data id", rootDataID, EventBase::INFO);
}

void
FSinkNode::displayResults(ostream& output) {
  output << "## WF OUTPUT (" << myId << ") :" << endl;
  myOutPort->writeAllDataAsList( output );
}

void
FSinkNode::toXML(ostream& output) {
  output << "<sink name=\"" << this->getId() << "\">" << endl;
  myOutPort->writeAllDataAsXML( output );
  output << "</sink>" << endl;
}

void
FSinkNode::getResultsInContainer(string& containerID) {
  containerID = myOutPort->getBufferContainerID();
}

/*****************************************************************************/
/*                             FProcNode                                     */
/*****************************************************************************/

FProcNode::FProcNode(FWorkflow* wf,
                     const string& id)
  : FNode(wf, id, N_INSTANC_READY), myRootIterator(NULL), cstDataLine(NULL)
{}

FProcNode::~FProcNode() {
  if (cstDataLine)
    delete cstDataLine;
  while (! myIterators.empty() ) {
    InputIterator * p = myIterators.begin()->second;
    myIterators.erase( myIterators.begin() );
    delete p;
  }
}

void
FProcNode::initDataLine() {
  if (cstDataLine == NULL) {
    // this data vector will be used as template for the data vector of each
    // instance. Its size equals the total nb of ports (including out ports)
    // but only in/inout/param port indexes will be used.
    cstDataLine = new vector<FDataHandle*>(getPortNb(), (FDataHandle*) NULL);
  }
}

PortInputIterator *
FProcNode::createPortInputIterator(const string& portId) {
  WfPort *wfPort;
  try {
    wfPort = getPort(portId);
  } catch (WfStructException& e) {
    throw WfStructException(WfStructException::eOTHER,
                            "unknown input for operator creation :" + e.Info());
  }
  FNodeInPort *inPort = dynamic_cast<FNodeInPort*>(wfPort);
  if (inPort == NULL)
    throw WfStructException(WfStructException::eOTHER,
                            "input operator applied to an output port");
  PortInputIterator *newPortIter = new PortInputIterator(inPort);
  myIterators[inPort->getId()] = (InputIterator*) newPortIter;
  return newPortIter;
}

bool
FProcNode::isIteratorDefined(const string& portId) {
  map<string,InputIterator*>::iterator iter = myIterators.find(portId);
  return (iter != myIterators.end());
}

const string&
FProcNode::createInputOperator(inputOperator_t opType, const vector<string>& inputIds) {
  vector<string>  _inputIds(inputIds);
  // convert N-cross to 2-cross using recursive call
  if (((opType == OPER_CROSS) || (opType == OPER_FLATCROSS))
      && (inputIds.size() > 2))
  {
    vector<string>  rightInputIds(++inputIds.begin(), inputIds.end());
    _inputIds.resize(2);
    _inputIds[0] = inputIds[0];
    _inputIds[1] = createInputOperator(opType, rightInputIds);
  }
  // convert inputIds to a table of iterator ref
  vector<InputIterator*> *inputIterTab = new vector<InputIterator*>(_inputIds.size());
  int inputIterIdx = 0;
  for (vector<string>::const_iterator idIter = _inputIds.begin();
       idIter != _inputIds.end();
       ++idIter) {
    const string& currId = *idIter;
    InputIterator* currInputIter = NULL;
    // first case: iterator already created => insert the ref in the table
    map<string,InputIterator*>::iterator iterFind = myIterators.find(currId);
    if (iterFind != myIterators.end()) {
      currInputIter = (InputIterator*) iterFind->second;
    } else {
      // second case: create iterator for single port
      currInputIter = (InputIterator*) createPortInputIterator(currId);
    }
    (*inputIterTab)[inputIterIdx++] = currInputIter;
  } // end for
  InputIterator *newOper;
  switch (opType) {
  case OPER_DOT:
    newOper = new DotIterator(*inputIterTab);
    break;
  case OPER_MATCH:
    WARNING("Match iterator currently experimental");
    newOper = new MatchIterator((*inputIterTab)[0], (*inputIterTab)[1]);
    break;
  case OPER_CROSS:
    newOper = new CrossIterator((*inputIterTab)[0], (*inputIterTab)[1]);
    break;
  case OPER_FLATCROSS:
    newOper = new FlatCrossIterator((*inputIterTab)[0], (*inputIterTab)[1]);
    break;
  }
  delete inputIterTab;
  myIterators[newOper->getId()] = newOper;
  return newOper->getId();
}

void
FProcNode::setRootInputOperator(const string& opId) {
  map<string,InputIterator*>::iterator iterFind = myIterators.find(opId);
  if (iterFind != myIterators.end()) {
    myRootIterator = (InputIterator*) iterFind->second;
  } else
    throw WfStructException(WfStructException::eOTHER,
                            "Root input operator '"+opId+"' not found");
}

void
FProcNode::setRootInputOperator(InputIterator * newOper) {
  map<string,InputIterator*>::iterator iterFind = myIterators.find(newOper->getId());
  if (iterFind != myIterators.end()) {
    throw WfStructException(WfStructException::eOTHER,
                            "Root input operator '"+newOper->getId()+"' already defined");
  } else {
    myIterators[newOper->getId()] = newOper;
    myRootIterator = newOper;
  }
}

void
FProcNode::setConstantInput(int idxPort, FDataHandle* dataHdl) {
  initDataLine();
  (*cstDataLine)[idxPort] = dataHdl;
}

bool
FProcNode::isConstantInput(int idxPort) {
  if (cstDataLine == NULL) return false;
  return ((*cstDataLine)[idxPort] != NULL);
}

void
FProcNode::checkDynamicParam(const string& paramName,
                             const string& paramValue) {
  // if value contains $ as first character then it's considered a variable
  string::size_type varTag = paramValue.find("$");
  if (varTag != 0) return;
  // get the name of the variable
  string paramVarName = paramValue.substr(1, paramValue.length()-1);
  // check if it's a valid dynamic parameter
  if (!(paramName == "path"))
    throw XMLParsingException(XMLParsingException::eINVALID_REF,
                              "attribute "+paramName+" cannot be dynamic");
  // store the association name => variable
  setDynamicParam(paramName, paramVarName);
}

void
FProcNode::setDynamicParam(const string& paramName,
                           const string& paramVarName) {
  dynParMap.insert(make_pair(paramName, paramVarName));
}

bool
FProcNode::isDynamicParam(const string& paramName) {
  map<string,string>::iterator iter = dynParMap.find(paramName);
  return (iter != dynParMap.end());
}

void
FProcNode::setDynamicParamValue(const string& paramVarName,
                                const string& paramValue) {
  varMap[paramVarName] = paramValue;
  TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Set parameter variable: " << paramVarName
              << "(value = " << paramValue << ")" << endl);
}

const string&
FProcNode::getDynamicParamValue(const string& paramName) {
  // get the name of the variable containing this parameter
  string varName;
  map<string,string>::iterator parIter = dynParMap.find(paramName);
  if (parIter != dynParMap.end())
    varName = parIter->second;
  else ERROR_EXIT("dynamic parameter '"+paramName+"' has no variable set");
  // get the value of the variable
  map<string,string>::iterator varIter = varMap.find(varName);
  if (varIter != varMap.end())
    return (varIter->second);
  else ERROR_EXIT("dynamic variable '"+varName+"' has no value set");
}

void
FProcNode::initialize() {
  TRACE_TEXT (TRACE_ALL_STEPS, traceId() << "Initializing processor" << endl);
  vector<string> *iterCreatedMap = new vector<string>(getPortNb());
  unsigned int iterCreatedNb = 0;
  // loop for all input or param ports
  for (unsigned int ix = 0; ix < getPortNb(); ++ix) {
    const FNodePort * port = dynamic_cast<const FNodePort*>(getPortByIndex(ix));
    string portId = port->getId();
    // check if current port is an input and is not constant
    if (((port->getPortType() == WfPort::PORT_IN)
         || (port->getPortType() == WfPort::PORT_INOUT)
         || (port->getPortType() == WfPort::PORT_PARAM))
        && !isConstantInput(ix)
        && !isIteratorDefined(portId)) {
      // create an iterator for the current port
      createPortInputIterator(portId);
      (*iterCreatedMap)[iterCreatedNb++] = portId;
    }
  }
  if (iterCreatedNb > 0) {
    if (iterCreatedNb == 1) {
      setRootInputOperator((*iterCreatedMap)[0]);
    } else {
      iterCreatedMap->resize(iterCreatedNb);
      TRACE_TEXT (TRACE_ALL_STEPS,"Creating default DOT iterator for all inputs" << endl);
      string parentIter = createInputOperator(OPER_DOT, *iterCreatedMap);
      setRootInputOperator(parentIter);
    }
  }
  // Initialize the dataline (in case it was not created before)
  initDataLine();
  delete iterCreatedMap;
}

void
FProcNode::initInstanciation() {
}

bool
FProcNode::instLimitReached() {
  return false;
}

void
FProcNode::createVoidInstance(const FDataTag& currTag,
                              vector<FDataHandle*>& currDataLine) {
  TRACE_TEXT (TRACE_MAIN_STEPS,"  ## NEW VOID INSTANCE : " << getId()
              << currTag.toString() << endl);
  // LOOP for each out port
  for (map<string,WfPort*>::iterator portIter = ports.begin();
       portIter != ports.end();
       ++portIter) {
    WfPort* port = (WfPort*) portIter->second;
    if (port->isOutput()) {
      FNodeOutPort* outPort = dynamic_cast<FNodeOutPort*>(port);
      // instanciate port with VOID data
      FDataHandle* dataHdl = outPort->createVoidInstance(currTag);
      // send data to connected nodes
      outPort->storeData(dataHdl);
      outPort->sendData(dataHdl);
    }
  }
  TRACE_TEXT (TRACE_ALL_STEPS,"  ## END OF VOID INSTANCE" << endl);
}

void
FProcNode::instanciate(Dag* dag) {
  if (instanciationReady()) {

    // Initialize the root input iterator
    if (!myRootIterator) {
      INTERNAL_ERROR("FProcNode::instanciate : no root iterator defined",1);
    }
    myRootIterator->begin();

    // Copy the constant dataline into the dataline used for the iteration
    if (!cstDataLine) {
      INTERNAL_ERROR("FProcNode::instanciate : no constant dataline defined",1);
    }
    vector<FDataHandle*>* currDataLine = new vector<FDataHandle*>(*cstDataLine);

    // Other initializations
    initInstanciation();

    //
    // LOOP OVER ITEMS in the INPUT QUEUE
    //
    while ( !myRootIterator->isAtEnd() && !instLimitReached()) {

      // GET DATALINE
      FDataTag currTag = myRootIterator->getCurrentItem(*currDataLine);
      myRootIterator->removeItem(); // goes to next item at the same time

      // CHECK IF VOID
      bool dataIsVoid = false;
      vector<FDataHandle*>::const_iterator DLIter = currDataLine->begin();
      while ((!dataIsVoid) && (DLIter!=currDataLine->end())) {
        FDataHandle* currDataHdl = *(DLIter++);
        dataIsVoid = currDataHdl ? currDataHdl->isVoid() : dataIsVoid;
      }

      if (!dataIsVoid) {

        // SET DYNAMIC PARAMETERS
        varMap.clear();
        for (map<string,WfPort*>::iterator portIter = ports.begin();
             portIter != ports.end();
             ++portIter) {
          WfPort* port = (WfPort*) portIter->second;
          if (port->getPortType() == WfPort::PORT_PARAM) {
            FNodeParamPort* paramPort = dynamic_cast<FNodeParamPort*>(port);
            FDataHandle* dataHdl = (*currDataLine)[paramPort->getIndex()];
            setDynamicParamValue(paramPort->getId(), dataHdl->getValue());
          }
        }

        // create a real instance of the node
        createRealInstance(dag, currTag, *currDataLine);

      } else {
        createVoidInstance(currTag, *currDataLine);
      }
    }
    //
    // END LOOP
    //

    updateInstanciationStatus();

    delete currDataLine;
  }
}


void
FProcNode::updateInstanciationStatus() {
  if (myRootIterator->isAtEnd()) {
    if (myRootIterator->isDone()) {
      TRACE_TEXT (TRACE_ALL_STEPS, traceId() <<  "########## ALL INPUTS PROCESSED" << endl);
      myStatus = N_INSTANC_END;

    } else {
      TRACE_TEXT (TRACE_ALL_STEPS, traceId() <<  "########## WAITING FOR INPUTS " << endl);
      myStatus = N_INSTANC_READY;
    }
  }
}

bool
FProcNode::hasDataToProcess() {
  myRootIterator->begin();
  return (!myRootIterator->isAtEnd());
}
