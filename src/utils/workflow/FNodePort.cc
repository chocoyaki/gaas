/****************************************************************************/
/* The class representing the ports of nodes of a functional workflow       */
/*                                                                          */
/* Author(s):                                                               */
/* - Benjamin ISNARD (benjamin.isnard@ens-lyon.fr)                          */
/*                                                                          */
/* $LICENSE$                                                                */
/****************************************************************************/
/* $Id$
 * $Log$
 * Revision 1.14  2009/07/30 09:43:09  bisnard
 * modified methods to free persistent data generated by workflow execution
 *
 * Revision 1.13  2009/07/23 12:31:56  bisnard
 * new methods for sink node results client access
 * modified access to wf ref for pending instances
 *
 * Revision 1.12  2009/07/10 12:52:08  bisnard
 * standardized FNodeInPort constructor
 *
 * Revision 1.11  2009/06/15 12:11:13  bisnard
 * use new XML Parser (SAX) for data source file
 * use new class WfValueAdapter to avoid data duplication
 * use new method FNodeOutPort::storeData
 * changed method to compute total nb of data items
 *
 * Revision 1.10  2009/05/27 08:49:43  bisnard
 * - modified condition output: new IF_THEN and IF_ELSE port types
 * - implemented MERGE and FILTER workflow nodes
 *
 * Revision 1.9  2009/05/15 11:10:20  bisnard
 * release for workflow conditional structure (if)
 *
 * Revision 1.8  2009/04/17 09:04:07  bisnard
 * initial version for conditional nodes in functional workflows
 *
 * Revision 1.7  2009/04/09 09:56:20  bisnard
 * refactoring due to new class FActivityNode
 *
 * Revision 1.6  2009/04/08 09:34:56  bisnard
 * pending nodes mgmt moved to FWorkflow class
 * FWorkflow and FNode state graph revisited
 * FNodePort instanciation refactoring
 *
 * Revision 1.5  2009/02/24 14:01:05  bisnard
 * added dynamic parameter mgmt for wf processors
 *
 * Revision 1.4  2009/02/06 14:55:08  bisnard
 * setup exceptions
 *
 * Revision 1.3  2009/01/16 13:54:50  bisnard
 * new version of the dag instanciator with iteration strategies for nodes with multiple input ports
 *
 * Revision 1.2  2008/12/09 12:15:59  bisnard
 * pending instanciation handling (uses dag outputs for instanciation
 * of a functional wf)
 *
 * Revision 1.1  2008/12/02 10:07:07  bisnard
 * new classes for functional workflow instanciation and execution
 *
 */

#include "debug.hh"
#include "DIET_data.h"
#include "FNodePort.hh"
#include "FNode.hh"
#include "FWorkflow.hh"
#include "DagNodePort.hh"
#include "Dag.hh"
extern "C" {
  #include "DIET_Dagda.h"
}

/**
 * Constructors & destructors
 */

FNodePort::FNodePort (WfNode * parent,
                      const string& _id,
                      WfPort::WfPortType _portType,
                      WfCst::WfDataType _type,
                      unsigned int _depth,
                      unsigned int _ind)
  : WfPort(parent, _id, _portType, _type, _depth, _ind) {
}

FNodePort::~FNodePort() {
}

FNodeOutPort::FNodeOutPort(WfNode * parent,
                           const string& _id,
                           WfPort::WfPortType _portType,
                           WfCst::WfDataType _type,
                           unsigned int _depth,
                           unsigned int _ind)
  : FNodePort(parent, _id, _portType, _type, _depth, _ind)
    , myBuffer(_depth+1) {
}

FNodeOutPort::~FNodeOutPort() {
}

FNodeInPort::FNodeInPort(WfNode * parent,
                           const string& _id,
                           WfPort::WfPortType _portType,
                           WfCst::WfDataType _type,
                           unsigned int _depth,
                           unsigned int _ind)
  : FNodePort(parent, _id, _portType, _type, _depth, _ind),
    dataTotalNb(0), totalDef(false), valueRequired(false) { }

FNodeInPort::~FNodeInPort() {
}

FNode*
FNodePort::getParentFNode() {
  FNode* parent = dynamic_cast<FNode*>(getParent());
  return parent;
}

FProcNode*
FNodePort::getParentProcNode() {
  FProcNode* parent = dynamic_cast<FProcNode*>(getParent());
  if (parent == NULL) {
    INTERNAL_ERROR("Invalid type of parent node for FNodePort " << getId() << endl,1);
  }
  return parent;
}

/**
 * Ports connection setup method
 * Called by WfSimpleAdapter on both sides to connect node ports
 */
void
FNodeOutPort::connectToPort(WfPort* remPort) {
  // set connected flag
  WfPort::connectToPort(remPort);
  // cast & add to list of connected in ports
  FNodeInPort* srcPort = dynamic_cast<FNodeInPort*>(remPort);
  if (srcPort == NULL) {
    INTERNAL_ERROR("Wrong connected node type in functional node OUT port", 0);
  }
  myConnectedPorts.push_back(srcPort);
}

/**
 * Instanciation
 */
FDataHandle*
FNodeOutPort::createRealInstance(Dag* dag, DagNode* nodeInst, const FDataTag& tag) {
  if (!nodeInst) {
    INTERNAL_ERROR("FNodeOutPort::instanciate called with NULL instance",1);
  }
  FDataHandle* dataHdl;
  // create the portInst (DagNodeOutPort) for the nodeInst
  string portId = this->getId();
  TRACE_TEXT (TRACE_ALL_STEPS,"   # Creating new instance of OUT port: " << portId << endl);
  WfPort* portInst = nodeInst->newPort(portId,
                                      nodeInst->getPortNb(),
                                      portType,
                                      getBaseDataType(),
                                      depth);
  DagNodeOutPort* portInstPtr = dynamic_cast<DagNodeOutPort*>(portInst);
  // create a FDataHandle corresponding to the new port instance
  //  - its depth equals the depth of the out port
  //  - its tag equals the tag of the node instance
  //  - its port equals the portInst
  dataHdl = new FDataHandle(tag, depth, false, portInstPtr);
  // set the cardinal information if available
  if (card) {
    dataHdl->setCardinalList(*card);
  }
  return dataHdl;
}

FDataHandle*
FNodeOutPort::createVoidInstance(const FDataTag& tag) {
  // create a VOID FDataHandle
  return new FDataHandle(tag, depth, true);
}

void
FNodeOutPort::storeData(FDataHandle* dataHdl) throw (WfDataHandleException) {
  TRACE_TEXT (TRACE_ALL_STEPS,"   # Insert data into buffer (" << getId() << ")" << endl);
  myBuffer.insertInTree(dataHdl);
}

void
FNodeOutPort::sendData(FDataHandle* dataHdl) throw (WfDataHandleException) {
  // add the new dataHandle to all the connected in ports ==> inPort.addData
  // all the inPort(s) that return false must be included in the FNode pending list
  TRACE_TEXT (TRACE_ALL_STEPS,"   # Insert data into connected ports" << endl);
  for (list<FNodeInPort*>::iterator inPortIter = myConnectedPorts.begin();
       inPortIter != myConnectedPorts.end();
       ++inPortIter) {
    FNodeInPort* inPort = (FNodeInPort*) *inPortIter;
    try {
      inPort->addData(dataHdl);
      checkTotalDataNb(inPort);
    } catch (WfDataHandleException& e) {
      if  (e.Type() == WfDataHandleException::eADAPT_UNDEF) {
        TRACE_TEXT (TRACE_ALL_STEPS," ==> insert failed (missing adapter)\n");
      } else if ((e.Type() == WfDataHandleException::eCARD_UNDEF)
          || (e.Type() == WfDataHandleException::eVALUE_UNDEF)) {
        TRACE_TEXT (TRACE_ALL_STEPS," ==> insert failed (missing value or cardinal)\n");
        if (dataHdl->isDataIDDefined()) {
          reSendData(dataHdl, inPort);
        } else {
          setPendingDataTransfer(dataHdl,inPort);
        }
      } else throw;
    }
  }
}

void
FNodeOutPort::sendAllData() throw (WfDataHandleException) {
  sendData(&myBuffer);
}

void
FNodeOutPort::setPendingDataTransfer(FDataHandle* dataHdl,
                                     FNodeInPort* inPort) {
  DagNodeOutPort* dagOutPort = dynamic_cast<DagNodeOutPort*>(dataHdl->getSourcePort());
  DagNode*        dagNode = dynamic_cast<DagNode*>(dagOutPort->getParent());
  FWorkflow*      wf = dagNode->getWorkflow();
  wf->setPendingInstanceInfo(dagNode,dataHdl,this,inPort);
}

/**
 * Dynamic sendData (if data available)
 * Used by workflow when processing pending instances
 */
void
FNodeOutPort::reSendData(FDataHandle* dataHdl, FNodeInPort* inPort)
    throw (WfDataException, WfDataHandleException) {
  TRACE_TEXT (TRACE_ALL_STEPS,"   # reSendData: uses data ID = "
                              << dataHdl->getDataID() << endl);
  // send the data to IN port
  try {
    inPort->addData(dataHdl);
    checkTotalDataNb(inPort);
  } catch (WfDataHandleException& e) {
    // a VALUE_UNDEF may be thrown in case the current data must be merged with
    // other data that is not yet available. In this case there is nothing to do
    // because the container DH will be received when the last element is added.
    if ((e.Type() != WfDataHandleException::eVALUE_UNDEF) &&
         (e.Type() != WfDataHandleException::eADAPT_UNDEF))
      throw;
  }
}

void
FNodeOutPort::checkTotalDataNb(FNodeInPort *inPort) {
  // determine the level corresponding to data items of the input port
  unsigned int inLevel = inPort->getDataLevel();
  // check if the tree is complete at this level
  if (myBuffer.checkIfComplete(inLevel)) {
    inPort->setTotalDataNb(myBuffer.getChildCount(inLevel));
  }
}

void
FNodeOutPort::updateDataTree() {
  myBuffer.updateTree();
}

void
FNodeOutPort::checkIfEmptyOutput() {
  if (myBuffer.isEmpty()) {
    for (list<FNodeInPort*>::iterator inPortIter = myConnectedPorts.begin();
       inPortIter != myConnectedPorts.end();
       ++inPortIter) {
      FNodeInPort* inPort = (FNodeInPort*) *inPortIter;
      inPort->setTotalDataNb(0);
    }
  }
}

void
FNodeOutPort::setAsConstant(FDataHandle* dataHdl) {
  if (dataHdl->getTag().getLevel() != 1) {
    INTERNAL_ERROR(__FUNCTION__ << "Invalid DH tag level",1);
  }
  // store this handle in my buffer (for deallocation)
  myBuffer.insertInTree(dataHdl);
  // set the connected in ports as constant with this handle
  for (list<FNodeInPort*>::iterator inPortIter = myConnectedPorts.begin();
       inPortIter != myConnectedPorts.end();
       ++inPortIter) {
    ((FNodeInPort*) *inPortIter)->setAsConstant(dataHdl);
  }
}

void
FNodeOutPort::freePersistentData(MasterAgent_var& MA) {
  TRACE_TEXT (TRACE_ALL_STEPS,"  # free persistent data (port " << getCompleteId()
                              << ")" << endl);
  myBuffer.freePersistentDataRec(MA);
}

/*****************************************************************************/
/*                            FNodeInPort                                    */
/*****************************************************************************/

void
FNodeInPort::setValueRequired() {
  valueRequired = true;
}

bool
FNodeInPort::isValueRequired() {
  return valueRequired;
}

/**
 * addData (RECURSIVE)
 */
void
FNodeInPort::addData(FDataHandle* dataHdl)
   throw (WfDataHandleException, WfDataException)
{
  TRACE_TEXT (TRACE_ALL_STEPS,"     # add data " << dataHdl->getTag().toString()
              << " to port " << getCompleteId()
              << (dataHdl->isValueDefined() ? " /value=" + dataHdl->getValue() : "")
              << endl);
  // if dataHdl is not complete then do nothing (happens due to recursive call to parent)
//   if (!dataHdl->isAdapterDefined() && !dataHdl->isValueDefined()) {
  if (!dataHdl->isAdapterDefined()) {
//     TRACE_TEXT (TRACE_ALL_STEPS,"Cannot add data to inPort (no value and no adapter)" << endl);
//     return
    TRACE_TEXT (TRACE_ALL_STEPS,"Cannot add data to inPort (no adapter)" << endl);
    throw WfDataHandleException(WfDataHandleException::eADAPT_UNDEF,
                                dataHdl->getTag().toString());
  }

  if (dataHdl->getDepth() == depth) {
    const FDataTag& dataTag = dataHdl->getTag();
    // check if value is required
    if ((valueRequired) && (!dataHdl->isValueDefined()))
      dataHdl->downloadValue();
//     if (myQueue.find(dataTag) == myQueue.end()) {
      TRACE_TEXT (TRACE_ALL_STEPS,"Adding data in input port queue (tag="
                  << dataTag.toString() << ")" << endl);
      myQueue.insert(pair<FDataTag,FDataHandle*>(dataTag, dataHdl));
      // updates node status
      getParentFNode()->setStatusReady();
//     } else {
//       //FIXME should this case happen ??
//     }

  // SPLIT CURRENT DATA => calls addData on the childrens
  } else if (dataHdl->getDepth() > depth) {
    if (dataHdl->isDataIDDefined()) {
      dataHdl->downloadElementDataIDs();
    }
    if (dataHdl->isCardinalDefined()) {
      TRACE_TEXT (TRACE_ALL_STEPS,"Adding data elements (SPLIT)" << endl);
      // loop over all elements of the data handle (begin may throw exception)
      for (map<FDataTag,FDataHandle*>::iterator eltIter = dataHdl->begin();
           eltIter != dataHdl->end();
           ++eltIter) {
        this->addData((FDataHandle*) eltIter->second);
      }
    } else {
      TRACE_TEXT (TRACE_ALL_STEPS,"Cardinal is required but not available (ADD cancelled)" << endl);
      throw WfDataHandleException(WfDataHandleException::eCARD_UNDEF,dataHdl->getTag().toString());
    }

  // MERGE => calls addData on the parent
  } else {
    if ((valueRequired) && (!dataHdl->isValueDefined()))
      dataHdl->downloadValue();
    if (dataHdl->isParentDefined()) {
      if (dataHdl->getTag().getLevel() <= 1) {
        // throw exception when the parent DH is the buffer's ROOT which should never be
        // used as a data itself. This means the workflow is badly built.
        throw WfDataHandleException(WfDataHandleException::eINVALID_ADAPT,
                                    "Cannot merge data higher than level 1 data");
      }
      TRACE_TEXT (TRACE_ALL_STEPS,"Trying to add parent (MERGE)" << endl);
      this->addData(dataHdl->getParent());
    } else {
      INTERNAL_ERROR("Missing data handle parent",0);
    }
  }
}

unsigned int
FNodeInPort::getDataLevel() {
  map<FDataTag,FDataHandle*>::const_iterator dataIter = myQueue.begin();
  if (dataIter != myQueue.end()) {
    return ((FDataHandle*)dataIter->second)->getTag().getLevel();
  } else {
    INTERNAL_ERROR("Called getDataLevel() on empty IN port",1);
  }
}

void
FNodeInPort::setTotalDataNb(unsigned int total) {
  dataTotalNb = total;
  totalDef = true;
  TRACE_TEXT (TRACE_ALL_STEPS,"Setting total to " << total
               << " for IN port : " << getCompleteId() << endl);
}

void
FNodeInPort::setAsConstant(FDataHandle* dataHdl) {
  FProcNode* node = getParentProcNode();
  node->setConstantInput(getIndex(), dataHdl);
//  node->setStatusReady(); ???
}

void
FNodeInPort::createRealInstance(Dag* dag, DagNode* nodeInst, FDataHandle* dataHdl) {
  if (!nodeInst) {
    INTERNAL_ERROR("FNodeInPort::instanciate called with NULL instance",1);
  }
  if (!dataHdl) {
    INTERNAL_ERROR("FNodeInPort::instanciate called with NULL data handle",1);
  }
  // create a DagNodeInPort for the nodeInst
  string portId = this->getId();
  TRACE_TEXT (TRACE_ALL_STEPS,"   # Creating new instance of IN port: " << portId << endl);
  WfPort* portInst = nodeInst->newPort(portId,
                                      nodeInst->getPortNb(),
                                      portType,
                                      getBaseDataType(),
                                      depth);
  // updates the dataID of the input data in case the value is available
  // (to avoid storing the same value multiple times in the dataMgr)
  if (dataHdl->isValueDefined() && !dataHdl->isDataIDDefined()) {
    TRACE_TEXT (TRACE_ALL_STEPS,"Updating dataID of data having a value" << endl);
    try {
      dataHdl->downloadDataID();
    } catch (WfDataException& e) {
      WARNING("Data initialization failure (" << e.ErrorMsg() << ")" << endl);
    }
  }
  WfPortAdapter * portAdapter = dataHdl->createPortAdapter(dag->getId());
  portInst->setPortAdapter(portAdapter);
  TRACE_TEXT (TRACE_ALL_STEPS,"Setting ADAPTER = " << portAdapter->getSourceRef() << endl);

}

void
FNodeInPort::displayData(ostream& output) {
  if (totalDef)
    output << "TOTAL NB OF RESULTS : " << dataTotalNb << endl;
  else
    output << "Warning: undefined total nb of results (error during instanciation)" << endl;
  int ix = 0;
  for (map<FDataTag,FDataHandle*>::const_iterator dataIter = myQueue.begin();
       dataIter != myQueue.end();
       ++dataIter) {
    FDataHandle*  currData = (FDataHandle*) dataIter->second;
    WfDataWriter* dataWriter = new WfListDataWriter(output);
    output << "[" << ix++ << "]=";
    try {
      currData->writeValue(dataWriter);
    } catch (WfDataException& e) {
      output << "<Error: " << e.ErrorMsg() << ">";
    }
    output << endl;
  }
}

void
FNodeInPort::getDataInContainer(string& containerID) {
  if (!totalDef) {
    WARNING("Warning: undefined total nb of results (error during instanciation)" << endl);
  }
  char* idCont;
  dagda_create_container(&idCont);
  int ix=0;
  for (map<FDataTag,FDataHandle*>::const_iterator dataIter = myQueue.begin();
       dataIter != myQueue.end();
       ++dataIter) {
    FDataHandle*  currData = (FDataHandle*) dataIter->second;
    currData->downloadDataID();
    if (!currData->isVoid()) {
      const string& idElt = currData->getDataID();
      if (!idElt.empty())
        dagda_add_container_element(idCont,idElt.c_str(),ix++);
      else
        throw WfDataException(WfDataException::eID_UNDEF,
                              "Sink '" + id + "' : empty data ID (tag="
                              + currData->getTag().toString() + ")");
    } else {
      dagda_add_container_null_element(idCont,ix++);
    }
  }
  containerID = idCont;
}

/*****************************************************************************/
/*                          FNodeParamPort                                   */
/*****************************************************************************/

FNodeParamPort::FNodeParamPort(WfNode * parent,
                           const string& _id,
                           WfCst::WfDataType _type,
                           unsigned int _ind)
  : FNodeInPort(parent, _id, WfPort::PORT_PARAM, _type, 0, _ind) {
  setValueRequired();
}

FNodeParamPort::~FNodeParamPort() {
}

void
FNodeParamPort::createRealInstance(Dag* dag, DagNode* nodeInst, FDataHandle* dataHdl) {
}


/*****************************************************************************/
/*                           FNodePortMap                                    */
/*****************************************************************************/

FNodePortMap::FNodePortMap() {
}

void
FNodePortMap::mapPorts(FNodeOutPort* outPort, FNodeInPort* inPort) {
  myPortMap[outPort] = inPort;
}

void
FNodePortMap::mapPortToVoid(FNodeOutPort* outPort) {
  myPortMap[outPort] = NULL;
}

void
FNodePortMap::applyMap(const FDataTag& tag, const vector<FDataHandle*>& dataLine) {
  for (map<FNodeOutPort*,FNodeInPort*>::const_iterator iter = myPortMap.begin();
       iter != myPortMap.end();
       ++iter) {
     FNodeOutPort* outPort = (FNodeOutPort*) iter->first;
     FDataHandle* dataHdl;
     if (iter->second) {
       FNodeInPort* inPort = (FNodeInPort*) iter->second;
       TRACE_TEXT (TRACE_ALL_STEPS," # Mapping " << inPort->getId()
                                    << " to " << outPort->getId() << endl);
       // COPY the input DH (with all its child tree)
       if (!dataLine[inPort->getIndex()]) {
         INTERNAL_ERROR("data handle for in port " << inPort->getId() << " not defined" << endl, 1);
       }
       dataHdl = new FDataHandle(tag, *dataLine[inPort->getIndex()]);
     } else {
       TRACE_TEXT (TRACE_ALL_STEPS," # Mapping VOID to " << outPort->getId() << endl);
       // CREATE a new VOID datahandle
        dataHdl = new FDataHandle(tag, outPort->getDepth(), true);
     }
     // Submit to out port (ie will send it to connected ports)
     outPort->storeData(dataHdl);
     outPort->sendData(dataHdl);
   }
}
