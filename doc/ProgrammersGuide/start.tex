%****************************************************************************%
%* DIET Programmer's Guide - chapter one                                    *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       *%
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%
%* $Id$
%* $Log$
%* Revision 1.4  2004/06/15 14:08:07  bdelfabr
%* adding files in table for data persistency
%*
%* Revision 1.3  2004/01/07 21:55:37  cpera
%* Add brief text on autotools and references.
%*
%* Revision 1.2  2003/11/28 11:54:44  pcombes
%* Add-ons about maintainer mode.
%*
%* Revision 1.1  2003/09/17 14:41:28  pcombes
%* Split the .tex according to its chapters.
%****************************************************************************%


\section{Using CVS}

There are two ways to get the source code for developers. DIET is published
under two forms of archive, and one of them contains all files that are
necessary to program in DIET: it is the maintainer mode archive. But the most
current way of getting the source files is to use the CVS.

Here are the CVS environment variables to set (of course, the programmer needs
an account on the GRAAL server so far):
\begin{description}
\item{\sf CVSROOT} \textsf{ = :ext:graal.ens-lyon.fr:/home/CVS}
\item{\sf CVSUMASK} \textsf{ = 000}
\item{\sf CVS\_RSH} \textsf{ = ssh}
\item{\sf CVSEDITOR [optional]} your favorite editor.
\end{description}

Once all these variables are set, just execute\\
\centerline{\sf cvs checkout GRAAL/devel/diet}\\


As many developers work on DIET simultaneously, it is important to commit files
only when it is proved that it will not hinder the other developers in their own
work. The consensual use of simultaneous developments is to perform an update of
each file just before editing it, then merge with the changes committed
in-between and test the local version to make sure that basic functionnalities
are not buggy. Commit the local version at last.

Deep changes should be preceeded by a discussion on the mailing list
\url{diet-dev@ens-lyon.fr} with all DIET developers.

On each commit, a log message is required. It is important that this log message
is clear enough for other developers to understand the outlines of the changes,
but it should remain concise. Try not to exceed two 80 character-lines.  Indeed,
the log messages are dumped into the files headers.


\section{Bootstrapping}

The compilation of DIET is managed by Makefiles generated and configured with
the autotools. \textsf{automake} generates a \makein\ in each
directory where there is a \makeam. \textsf{autoconf} generates a
\configure\ script from a \texttt{configure.ac} and all m4 macros in
\texttt{acmacro}. This script fills in all configuration-dependent fields of the
\makein\ files to generate the final Makefiles - see Figure
\ref{fig:autochain}.

If you have to add a file, or if you have to modify the
compilation dependence of an existing file in DIET, then you will have to modify
a \makeam, and this requires \textsf{automake 1.7} or
higher. Please make sure you have it installed on your system.


\begin{figure}[hbt]
\begin{center}
\includegraphics[scale=.65]{fig/autotools_chain.eps}
\end{center}
\label{fig:autochain}
\caption{The autotools chain}
\end{figure}

We have added to the root of the source code tree a short script that performs
the most part of the chain: \textsf{bootstrap.sh}. As long as you have the right
version of the autotools (\textsf{automake} is the reference),
\textsf{bootstrap.sh} will do everything but the configuration of the
\makein\ files.\\

%\fixme{Christophe - Tell more about the versions and the libtool}\\

You will find more details about Autotools and Bootstrap.sh shell script 
(which contains calls to libtoolize, aclocal, autoheader, automake and 
autoconf) in Annexe 1.


\noindent
\fbox{\textbf{NB}} In the maintainer distribution, the bootstrapping has been already
performed, so that there is no need for \textsf{automake 1.7} if you simply
intent to modify a file. Nevertheless, there are also all the files necessary
for regenerating the autotools chain as long as you have \textsf{automake 1.7}
installed. So that you can also alter the \makeam.

\noindent
\fbox{\textbf{NB}} Currently, DIET is developped with at least libtool 1.4.3,
automake 1.7.3 and autoconf 2.57. Previous version of these tools can generate
misbehavior or cannot collaborate correctly.

\section{Configuring and compiling as a programmer}

Among the numerous options of the \configure\ script, there is a feature that
a programmer should enable: \texttt{--enable-maintainer-mode}. Enabling this feature
\begin{description}
\item{}makes the \make\ and \makein\ files dependent from the associated \makeam,
    i.e., when executing \texttt{make} in the directory where a \makeam\ is
    changed (directly, or through an upper-level \texttt{make}), the \makein\ is
    first regenerated and then configured into the \make\ with the options used
    at the first configuration~;
\item{}activates all the parts of the \makeam\ files enclosed between the
    instrutions \texttt{\footnotesize if MAINTAINER\_MODE} and the matching
    \texttt{\footnotesize else or endif}, such as:
    \begin{itemize}
    \item{combined with \texttt{--enable-doc}, the compilation of this
        Programmer's Guide and the generation of the Doxygen documentation (in
        doc/API);}
    \item{the files to remove or add to the distribution archive: in maintainer
        mode, the target \texttt{distrib} of the root \make generated a
        maintainer mode archive;}
    \item{the addition of the flag \texttt{-g} in the compilations (instead of
        \texttt{-O2} in the user version;}
    \item{the compilation of the classical examples (see section
        \ref{s:examples}) which is disabled by default in user mode.}
    \end{itemize}
\end{description}

As the maintainer mode option alters significantly the behaviour of the
compilation, we strongly recommend to configure and compile in a
different directory than the root of the source code tree. This has got two main
advantages:
\begin{enumerate}
\item{the CVS operations, such as diffing or committing, are greatly eased in
    the source code tree (no need to worry about the generated files, except
    \makein)~;}
\item{as it is important that the programmer knows exactly how his modifications
  will behave from the user point of view, it is better to keep a directory
  configured whithout the maintainer mode option, and to test the changes in the
  user mode as well as in the developer mode. But, it is not possible to
  configure with maintainer mode in the source code tree, and without in another
  tree (the presence of the \make\ in the root directory will make the second
  configuration fail.}
\end{enumerate}
The other options for the \configure\ script are described in its help
(\texttt{--help} option). Here is the example of my source tree, got from the
CVS server:
\begin{verbatim}
~ > cvs checkout GRAAL/devel/diet
~ > cd GRAAL/devel/diet
~/GRAAL/devel/diet > mkdir build_dev build_usr
~/GRAAL/devel/diet > cd build_usr
~/GRAAL/devel/diet/build_usr > ../configure --srcdir=.. <options>
...
~/GRAAL/devel/diet/build_usr > cd ../build_dev
~/GRAAL/devel/diet/build_usr > ./configure --srcdir=.. --enable-maintainer-mode
<same options>
...
\end{verbatim}

Finally, it is also strongly recommended to make your modifications using FAST,
or at least to test them with a whole platform before submitting them. A script
\texttt{local\_platform} is given with the distrbution (in
\textsf{bin/scripts}), which launches
\begin{itemize}
\item a mini LDAP base with the services \textsf{base/mult},
  \textsf{base/plus}, and \textsf{dgemm}, with the output of the FAST bencher
  that Martin made on his machine (but who cares right values for tests ?) ;
\item and four NWS entities: the three mandatory ones, \texttt{nws\_nameserver},
  \texttt{nws\_memory} and \texttt{nws\_forecaster}, and one sensor for the
  local machine, \texttt{nws\_sensor} ; their ports are the ones used in the
  default configuration files of DIET.
\end{itemize}
So, as it is quite easy to launch a local platform, please do not hesitate
configuring DIET with FAST.


\section{Before altering DIET ...}

Once your environment has been set up, you are almost ready to add your
modifications in DIET. But, unless you are very well informed about the way DIET
is structured, please respect the following steps:
\begin{enumerate}
\item Decide which DIET entities are concerned by your changes.
\item ( For Eddy, are my changes \underline{\textbf{really}} useful ? )
\item Read carefully the paragraphs in chapter \ref{ch:tree} about the
  directory that deal with this entity (even if reading the chapter in a whole
  can only be a good thing ...).
\item Read \underline{\textbf{carefully}} the Coding Standards in chapter
  \ref{ch:CS}.
\item Include your modifications in the compilation chain (you may have nothing
  to do if you do not create any file, except your changes modify the
  dependencies)
\end{enumerate}


\section{Adding a file or a directory in the compilation chain}

%\fixme{Christophe - please check up and complete this part}\\

Understanding the conception of a \makeam\ in DIET is not that easy. The problem
is that we have to build two libraries (\textsf{DIET\_client} and
\textsf{DIET\_SeD}) and one binary executable (\textsf{dietAgent}) using great
amount of common source code.

\subsection{Adding a file in a ``terminal'' directory}

A ``terminal'' directory is a directory where a library or an executable is
generated.\\

Let us take the example of the generation of the executable \textsf{dietAgent}.
It is declared in the Makefile variable \texttt{bin\_PROGRAMS}, and the
corresponding variable \texttt{dietAgent\_SOURCES} lists all source files of the
current diectory involved in this executable. The names of the variables are
important, since they tell \textsf{automake} what to compile and how.
\begin{verbatim}
bin_PROGRAMS = dietAgent
dietAgent_SOURCES = dietAgent.cc AgentImpl.cc ...
\end{verbatim}
For the \textsf{DIET\_SeD} library, for instance, it would be:
\begin{verbatim}
lib_LTLIBRARIES = libDIET_SeD.la
libDIET_SeD_la_SOURCES = DIET_server.cc SeDImpl.cc
\end{verbatim}

The source files in the other directories are not included directly, but as
temporary libraries (\textsf{.la}). They are taken into account thanks to the
Makefile variable \texttt{dietAgent\_LDADD} (or
\texttt{libDIET\_SeD\_la\_LIBADD}) that lists all the temporary libraries to
include in the generation of \textsf{dietAgent} (resp. \textsf{libDIET\_SeD.a}
and \textsf{libDIET\_SeD.so}).\\

Thus, adding a \texttt{.cc} file in a ``terminal'' directory implies only adding
its name in the \texttt{*\_SOURCES} variable. If there is an associated
\texttt{.hh} (or a header file alone), it has to be added in the variable
\texttt{noinst\_HEADERS} (the headers that we do not want to copy in the
\texttt{$<$install\_dir$>$/include} directory - see section \ref{s:include})


\subsection{Adding a file in a ``non-terminal'' directory}

In a ``non-terminal'' directory, we have to generate temporary libraries
(\textsf{.la}) that will be included in the final libraries or executables. Of
course it is possible to group all files of the directory in a big library:
\\
\begin{tabular}{l}
\tt
noinst\_LTLIBRARIES = libBIGLIBRARY.la\\
\tt
libBIGLIBRARY\_la\_SOURCES = \$(wildcard *.cc)\\
\end{tabular}
\\
But this will make the final libraries and executables much bigger than
necessary, since they would include dead code (code that they would never use)
That is why we decided to group the files of each directory into different
libraries, depending on the ``destinations'' of the modules\footnote{A module
  consists of a \textsf{.h} or \textsf{.hh} and its associated \textsf{.c} or
  \textsf{.cc}. For instance, the header and the implementation of a class.},
i.e. depending on the final binaries that use them. Please refer to the
dependency table \ref{t:dep}, which every DIET programmer is asked to maintain
whereas he alters the repartition of these libraries, because of new files or
modifications that change the dependencies.
\\

\noindent
To add a new module in a non-terminal directory,
\begin{enumerate}
\item Add its line in the table \ref{t:dep} (in the section of its directory),
  and put an 'x' in each column where it is used.
\item Then you can find to which temporary library you must add it: the library
  that matches the same combination of 'x' in the table, or if none, a new one.
\item Add the \textsf{.cc} file in the corresponding \texttt{*\_SOURCES}
  variable of the \makeam\ in the directory. For instance:\\
\texttt{libCorbaCommon\_la\_SOURCES = ORBMgr.cc marshalling.cc}
\item If you have created a new temporary library, just add its relative path
  and name in the \texttt{*\_LDADD} Makefile variables of the binaries that need it.
\end{enumerate}
To add a header only (such as \texttt{src/agent/NodeDescription.hh}), just
complete the variable \texttt{noinst\_HEADERS} in the \makeam\ of the directory.
\\

\begin{table}[h]
 \footnotesize
 \centering
 \fixme{Bruno - Pease add your files for data persistency ...}
 \begin{tabular}[c]{|l|c|c|c|l|}
  \hline
  Modules  &
  \begin{minipage}[c]{1.65cm}
   \centering used in\\ \texttt{dietAgent}
  \end{minipage}                  &
  \begin{minipage}[c]{1.65cm}
   \centering used in\\ \texttt{DIET\_SeD}
  \end{minipage}                  &
  \begin{minipage}[c]{1.65cm}
   \centering used in\\% \hspace*{-5pt}
   \texttt{DIET\_client}
  \end{minipage}                  &
  \textsf{.la} library to add to\\[5pt]
  \hline
  
  % AGENT
  \multicolumn{1}{|l}{\textsf{src/agent}:} &
  \multicolumn{4}{l|}{\texttt{dietAgent}}\\[5pt]

  \textit{all files}              & x &   &   & \emph{none}\\[5pt]
  \hline
  
  % CLIENT
  \multicolumn{1}{|l}{\textsf{src/client}:} &
  \multicolumn{4}{l|}{\texttt{libDIET\_client.[a|so]}}\\[5pt]

  \textit{all files}              &   &   & x & \emph{none}\\[5pt]
  \hline

  % CORBA
  \multicolumn{1}{|l}{\textsf{src/CORBA}:} &
  \multicolumn{4}{l|}{\texttt{libCorbaCommon.la}}\\[5pt]

  \texttt{marshalling}            & x & x & x & \texttt{libCorbaCommon.la}\\
  \texttt{ORBMgr}                 & x & x & x & \texttt{libCorbaCommon.la}\\[5pt]
  \hline

  % CORBA/idl
  \multicolumn{1}{|l}{\textsf{src/CORBA/IDL}:} &
  \multicolumn{4}{l|}{\texttt{libIDLCommon.la libIDLAgent.la
                              libIDLLA.la libIDLMA.la}}\\[5pt]

  \texttt{Agent[Dyn]SK}           & x & x &   & \texttt{libIDLAgent.la}\\
  \texttt{LocalAgent[Dyn]SK}      & x &   &   & \texttt{libIDLLA.la}\\
  \texttt{MasterAgent[Dyn]SK}     & x &   & x & \texttt{libIDLMA.la}\\
  \texttt{Callback[Dyn]SK}        & x & x & x & \texttt{libIDLCommon.la}\\
  \texttt{SeD[Dyn]SK}             & x & x & x & \texttt{libIDLCommon.la}\\
  \texttt{common\_types[Dyn]SK}   & x & x & x & \texttt{libIDLCommon.la}\\
  \texttt{response[Dyn]SK}        & x & x & x & \texttt{libIDLCommon.la}\\
  \texttt{DataMgr[Dyn]SK}        & x & x & x & \texttt{libIDLAgent.la}\\
  \texttt{LocMgr[Dyn]SK}        & x & x & x & \texttt{libIDLAgent.la}\\[5pt]
  \hline

  % SED

  \multicolumn{1}{|l}{\textsf{src/SeD}:} &
  \multicolumn{4}{l|}{\texttt{libDIET\_SeD.[a|so]}}\\[5pt]

  \textit{all files}              &   & x &   & \emph{none}\\[5pt]
  \hline

  % UTILS

  \multicolumn{1}{|l}{\textsf{src/utils}:} &
  \multicolumn{4}{l|}{\texttt{libUtilsCichlid.la libUtilsCommon.la 
                             libUtilsSeDClt.la  libUtilsNodes.la}}\\[5pt]

  \texttt{com\_tools}             &   &   & x & \texttt{libUtilsCichlid.la}\\
  \texttt{Counter}                & x & x &   & \texttt{libUtilsNodes.la}\\
  \texttt{debug}                  & x & x & x & \texttt{libUtilsCommon.la}\\
  \texttt{DIET\_data}             & x & x & x & \texttt{libUtilsCommon.la}\\
  \texttt{DIET\_mutex}            &   & x & x & \texttt{libUtilsSeDClt.la}\\
  \texttt{FASTMgr}                & x & x &   & \texttt{libUtilsNodes.la}\\
  \texttt{ms\_function}           & x & x & x & \texttt{libUtilsCommon.la}\\
  \texttt{Parsers}                & x & x & x & \texttt{libUtilsCommon.la}\\
  \texttt{ServiceTable}           & x & x &   & \texttt{libUtilsNodes.la}\\
  \texttt{statistics}             & x & x & x & \texttt{libUtilsCommon.la}\\[5pt]
  \hline
 

 \end{tabular}
 \caption{Dependencies of the final binaries from the temporary libraries}
 \label{t:dep}
\end{table}


\noindent
\fbox{\textbf{NB}} The particular case of the sub-directory \textsf{IDL} will be
discussed in section \ref{s:IDL}. Indeed, it cannot be processed as the other
ones, since the \textsf{.idl} files are the true source files. The \textsf{.cc}
and \textsf{.hh} files are ``built sources'' generated from the \textsf{.idl}.



\subsection{Adding a directory}

We will discuss here the criteria that makes the creation of a new directory
sensible. We will just mention, as exposed in the \textit{Coding Standards}
(chapter \ref{ch:CS}), that such changes should be discussed on the developers
mailing list, \url{diet-dev@ens-lyon.fr}.
\\
We will not discuss neither the way to add the directory in the CVS repository,
since this has nothing to do here.

Once it has been decided to add a new directory, and once its own \makeam\ is
written, then it has to be reported
\begin{itemize}
\item in the \makeam\ of its parent directory: it must be added in the variable
  \texttt{SUBDIRS}, and also in \texttt{DIST\_SUBDIRS} if it is expected to
  appear in the final distribution;
\item in the root \texttt{configure.ac}, where all the \makein to create (and to
  configure) are listed - macro \texttt{AC\_CONFIG\_FILES}.
\end{itemize}

