%****************************************************************************%
%* DIET User's Manual plugin scheduler chapter file                         *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - Alan SU (Alan.SU@ens-lyon.fr)                                       *%
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \documentclass{article}

\newenvironment{code}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\bfseries\tt}
{\end{list}}

\newenvironment{tinycode}
{\begin{list}{}{\setlength{\leftmargin}{1em}}\item\tiny\bfseries\tt}
{\end{list}}

%% \begin{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{Scheduling in DIET}
\label{ch:plugin}

\section{Introduction}

We introduce a
\emph{plugin scheduling} facility, designed to allow DIET service
developers to define application-specific performance measures and
to implement corresponding scheduling strategies.  This section
describes the default scheduling policy in DIET and the interface to
the plugin scheduling facility.

\section{Default Scheduling Strategy}\label{sect:default_sched}

The DIET scheduling subsystem is based on the notion that, for the
sake of system efficacy and scalability, the work of
determining the appropriate schedule for a parallel workload should be
distributed across the computational platform.  When a task in
such a parallel workload is submitted to the system for processing,
each Server Daemon (SeD) provides a
\emph{performance estimate}~-- a collection of data pertaining to
the capabilities of a particular server in the context of a particular
client request~-- for that task.  These estimates are
passed to the server's parent agent; agents then
sort these responses in a manner that optimizes certain performance
criteria.
Effectively, candidate SeDs are identified through a distributed
scheduling algorithm based on
pairwise comparisons between these
performance estimations; upon receiving server responses from its
children, each agent performs a local scheduling operation called
\emph{server response aggregation}.  The end result of the agent's
aggregation phase is a list of server responses (from servers in the
subtree rooted at said agent), sorted according to the
aggregation method in effect.
By default, the aggregation phase
implements the following ordered sequence of tests:

\begin{enumerate}
\item \textbf{FAST/NWS data}: SeDs compiled properly configured with
  FAST~\cite{Qui02} and
  NWS~\cite{WSH99}
  are capable of making dynamic
  performance estimates.  If such data
  were generated by the SeDs, these are the metrics on which agents
  select servers.
\item \textbf{Round-robin}: In the absence of application- and
  platform-specific performance
  data, the DIET scheduler attempts to probabilistically achieve load
  balance by assigning client requests on a round-robin
  basis.  Essentially each server records a timestamp indicating the
  last time at which it was assigned a job for execution.  Each time a
  request is received, the SeD computes the time elapsed since its
  last execution, and among the responses it receives, DIET agents
  select SeDs with a longer elapsed time.
\item \textbf{Random}: If the SeD is unable to store
  timestamps, the DIET scheduler will chose randomly when
  comparing two otherwise equivalent SeD performance estimations.
\end{enumerate}

In principle, this scheduling policy prioritizes servers that are able
to provide useful performance prediction information (as provided by
the FAST and NWS facilities).  In general, this approach works well
when all servers in a given DIET hierarchy are capable of making such
estimations.  However, in platforms composed of SeDs with varying
capabilities, load imbalances may occur: since DIET systematically
prioritizes server responses containing FAST and/or NWS data, servers
that do not respond with such performance data will be never be
chosen.

We have designed a plugin scheduler facility to 
enable the application developer to tailor the DIET scheduling to the
targeted application.
This functionality provides
the application developer the means to extend the notion of a
performance estimation to include metrics that are
application-specific, and to instruct DIET how to treat those data in
the aggregation phase.
We describe these interfaces in the following sections.


\section{Plugin Scheduler Interface}

Distributed applications are varied and often exhibit performance
behavior specific to the domain from which they arise.  Consequently,
application-specific scheduling approaches are often necessary to
achieve high-performance execution.  We propose an extensible
framework to build
\emph{plugin schedulers}, enabling application developers to specify
performance estimation metrics that are tailored to their individual
needs.

%% This section introduces the principal components of the basic plugin
%% scheduler framework.

\subsection{Estimation Metric Vector}\label{sect:estvector}

The new type \texttt{estVector\_t} is a structure that can manage a
dynamic collection of performance estimation values.  Logically, we
refer to such an object as an \emph{estimation vector}, containing
values that represent the performance profile provided by a
SeD in response to a DIET service request.  This collection of values
may contain either standard performance measures that are available
through DIET, or developer-defined values that are meaningful in
the context of the application being developed.

\subsubsection{Standard Performance Metrics}

To allow users to use the existing default performance estimation
routines (as described in Section~\ref{sect:est_fn}), the following
functions are available to facilitate the construction of custom
performance estimation functions:
\begin{itemize}
\item FAST- and NWS-based performance estimation metrics (contingent
  on availability of these packages at compilation time) are stored in
  an estimation metric vector by calling
  \begin{tabbing}
    \texttt{int diet\_estimate\_fast(}\=\texttt{estVector\_t ev,} \\
    \> \texttt{const diet\_profile\_t* const profilePtr)}:
  \end{tabbing}
   with an appropriate value for \texttt{ev} and the
   \texttt{profilePtr} corresponding to the current DIET request.
\item The time elapsed since the last execution (to enable
  the round-robin scheduler) is stored in an estimation metric vector
  by calling
  \begin{tabbing}
    \texttt{int diet\_estimate\_lastexec(}\=\texttt{estVector\_t ev,} \\
    \> \texttt{const diet\_profile\_t* const profilePtr)}:
  \end{tabbing}
  with an appropriate value for \texttt{ev} and the
  \texttt{profilePtr} corresponding to the current DIET request.

\end{itemize}

In the future, we plan to expand the suite of default estimation
metrics to include other performance estimation systems
(e.g.,~ganglia) and dynamic internal DIET system state information
(e.g.,~queue lengths).

\subsubsection{Developer-defined Performance Metrics}

Application developers may also define performance values to be
included in a SeD response to a client request.  For example, a DIET
SeD that provides a service to query particular databases may need
to include information about which databases are currently resident in
its disk cache, in order that an appropriate server be identified for
each client request.  To store such values, the SeD developer should
utilize the following interface:
\begin{code}
int diet\_set\_user\_estimate(estVector\_t ev, int userTag, double value);
\end{code}
where the \texttt{userTag} parameter is an arbitrary integer value
used in the definition of custom server response aggregation
methods (described in Section~\ref{sect:agg_methods}).
Such a call instructs DIET to store in the estimation vector
\texttt{ev} the value \texttt{value} associated with the identifier
\texttt{userTag}.

\subsection{Estimation Function}\label{sect:est_fn}

The default behavior of a SeD when a service request arrives from
its parent agent is to store the following information in the
request profile:
\begin{enumerate}
\item \textbf{FAST-based execution time predictions}: DIET SeDs
  attempt to call FAST
  routines to obtain execution time predictions based on the type of
  service requested, if FAST was available at compilation time.  If
  available, such predictions are stored in the
  performance estimate.
\item \textbf{NWS-based dynamic resource information}: If NWS library
  functions are available, performance estimates may include dynamic
  resource performance information about CPU availability, free
  memory, and network bandwidth.
\item \textbf{Elapsed time since last execution}: To implement the
  default round-robin behavior in absence of FAST and NWS facilities,
  each SeD stores a timestamp of its last execution.  When a service
  request arrives, the difference between that timestamp and the
  current time is added to the performance estimate.
\end{enumerate}
This is accomplished by using the \texttt{diet\_estimate\_fast} and
\texttt{diet\_estimate\_lastexec} functions described in
Section~\ref{sect:estvector}.

To implement a plugin scheduler, we define an
interface that admits customizable performance estimation routines:
\begin{code}
  typedef estVector\_t (* diet\_perfmetric\_t)(diet\_profile\_t*);\\
  \\
  diet\_perfmetric\_t\\
  diet\_service\_use\_perfmetric(diet\_perfmetric\_t perfmetric\_fn);\\
\end{code}
Thus, the type \texttt{diet\_perfmetric\_t} is a function pointer
that returns a performance estimation (represented by the
\texttt{est\_vector\_t} object), given a DIET service request
profile.  The application
developer can associate such a function, or
\emph{performance estimation routne}, with DIET services via the
\texttt{diet\_service\_use\_perfmetric} interface.  This interface
returns the previously registered performance estimation routine, if
one was defined (and
\texttt{NULL} otherwise).  At this point, a service added using the
\texttt{diet\_service\_table\_add} function will be associated with
the declared performance estimation routine.
Additionally, a performance estimation routine so specified will be
associated with \emph{all} services added into the service table until
another call to the
\texttt{diet\_service\_use\_perfmetric} interface is made.

\subsection{Aggregation Methods}\label{sect:agg_methods}

At the time a DIET service is defined, an \emph{aggregation method}~--
the logical mechanism by which SeD responses are sorted~-- is
associated with the service; the default behavior was described in
Section~\ref{sect:default_sched}.

If application-specific data \emph{are} supplied (i.e.,~the
estimation function has been redefined), an alternative method for
aggregation is needed.  Currently, a basic
\emph{priority scheduler} has been implemented, enabling an
application developer to specify a series of performance values that
are to be optimized in succession.  A developer may implement a
priority scheduler using the following interface:
\begin{code}
\begin{tabbing}
diet\_aggregator\_desc\_t* \\
diet\_profile\_desc\_aggregator(diet\_profile\_desc\_t* profile); \\
\\
int diet\_aggregator\_set\_type(\=diet\_aggregator\_desc\_t* agg, \\
\> diet\_aggregator\_type\_t atype); \\
\\
int diet\_aggregator\_priority\_max(\=diet\_aggregator\_desc\_t* agg, \\
\> diet\_est\_tag\_t tag); \\
\\
int diet\_aggregator\_priority\_min(\=diet\_aggregator\_desc\_t* agg, \\
\> diet\_est\_tag\_t tag); \\
\\
int diet\_aggregator\_priority\_maxuser(\=diet\_aggregator\_desc\_t* agg, \\
\> int val); \\
\\
int diet\_aggregator\_priority\_minuser(\=diet\_aggregator\_desc\_t* agg, \\
\> int val); \\
\end{tabbing}
\end{code}
The \texttt{diet\_profile\_desc\_aggregator} and
\texttt{diet\_aggregator\_set\_type} functions fetch and configure the
aggregator corresponding to a DIET service profile, respectively.
In particular, a priority scheduler is declared by invoking the latter
function with \texttt{DIET\_AGG\_PRIORITY} as the \texttt{agg}
parameter.
Recall that from the point of view of an agent, the aggregation phase
is essentially a sorting of the server responses from its children.
A priority scheduler logically uses a series of user-specified tags to
perform the pairwise server comparisons needed to construct the 
sorted list of server responses.

To define the tags and the order in which they should be compared,
four functions are introduced.  These functions, of the form
\texttt{diet\_aggregator\_priority\_*}, serve to identify the
estimation values to be optimzed during the aggregation phase.  The
\texttt{\_min} and \texttt{\_max} forms indicate that a standard
performance metric (e.g.,~time elapsed since last execution, from the
\texttt{diet\_estimate\_lastexec} function) is to be either
minimized or maximized, respectively.  Similarly, the
\texttt{\_minuser} and \texttt{\_maxuser} forms indicate the analogous
operations on user-supplied estimation values.  Calls to these
functions indicate the order of \textbf{precedence} of the tags.

Each time two server responses need to be compared, the values
associated with the tags specified in the priority aggregator are
retrieved.  In the specified order, pairs of corresponding values are
successively compared, passing to the next tag only if the values for
the current tag are identical.  If one server response contains a
value for the metric currently being compared, and another does not,
the response with a valid value will be selected.  If at any point
during the treatment of tags \emph{both} responses lack the necessary
tag, the comparison is declared indeterminate.
This process continues until one response is
declared superior to the other, or all tags in the priority aggregator
are exhaused (and the responses are judged equivalent).


\section{Example}

A new example has been added to the DIET distribution to illustrate
the usage of the plugin scheduler functionality; this code is
available in the directory
\begin{code}
src/examples/plugin\_example/
\end{code}
Provided are a DIET server and client, corresponding to a simulation
of a database research application.  If the construction of examples
was enabled during DIET configuration, two binaries \texttt{server}
and \texttt{client} will be built in this directory.  Having deployed
a DIET agent hierarchy, the server may be instantiated:
\begin{code}
  \$ server <SeD\_config> <DB> [ <DB> ... ]
\end{code}
where \texttt{<DB>} are string(s) that represent the existence of
a particular database at the SeD's site.  A client would pose a query
against a set of databases:
\begin{code}
  \$ client <client\_config> <DB> [ <DB> ... ]
\end{code}
The application uses the plugin scheduling facility to prioritize the
existence of databases in selecting a server, and thus, the expected
result is that one of the SeDs with the fewest number of database
mismatches will be selected.

In the \texttt{main} function of the \texttt{server.c} file, the
following block of code (a)~specifies the use of the priority
aggregator for this service, (b)~declares a performance estimation
function to supply the necessary data at request-time, and
(c)~defines the order of precedence of the performance values
(i.e.,~minimizing the number of database mismatches, and then
maximizing the elapsed execution time).
\begin{code}
  \{
    /* new section of the profile: aggregator */ \\
    diet\_aggregator\_desc\_t *agg; \\
    agg = diet\_profile\_desc\_aggregator(profile); \\
\\
    /* point the DIET server code to our custom performance function */ \\
    diet\_service\_use\_perfmetric(performanceFn);~~~~~~~~~~~~~~~~/* (b) */ \\
\\
    /* for this service, use a priority scheduler */ \\
    diet\_aggregator\_set\_type(agg, DIET\_AGG\_PRIORITY);~~~~~~~~~~/* (a) */ \\
    diet\_aggregator\_priority\_minuser(agg, 0);~~~~~~~~~~~~~~~~~~/* (c) */ \\
    diet\_aggregator\_priority\_max(agg, EST\_TIMESINCELASTSOLVE);~/* (c) */ \\
  \}
\end{code}
The performance function \texttt{performanceFn} is defined as follows:
\begin{code}
typedef estVector\_t (* diet\_perfmetric\_t)(diet\_profile\_t*); \\
\\
static estVector\_t \\
performanceFn(diet\_profile\_t* pb) \\
\{ \\
  const char *targetString; \\
  int numMismatch; \\
  estVector\_t perfValues = diet\_estimate\_new\_vector(); \\
\\
  /* string value must be fetched from description; value is NULL */ \\
  targetString = (diet\_paramstring\_get\_desc(diet\_parameter(pb, 0)))->param; \\
  numMismatch = computeMismatches(targetString); \\
\\
  /* store the mismatch value in the user estimate space */ \\
  diet\_set\_user\_estimate(perfValues, 0, numMismatch); \\
\\
  /* also store the elapsed time since last execution */ \\
  diet\_estimate\_lastexec(perfValues, pb); \\
\\
  return (perfValues); \\
\}
\end{code}
The function \texttt{computeMismatches} (defined earlier in
\texttt{server.c}) calculates the number of requested databases that
are not present on the SeD making the evaluation.
Together, the \texttt{performanceFn} function and the block of code
added to \texttt{main} serve to customize the generation of
performance information and the treatment of these data in the context
of the simulated database search.
Finally, it should be noted that the client code is not affected by
the introduction of a plugin scheduler.

\section{Future Work}

We have two primary efforts planned for extensions to the plugin
scheduler.
\begin{itemize}
\item \textbf{Additional information services}: We plan to add
  functionality to enable the application developer to access and use
  data concerning the internal state of the DIET server (e.g.,~the
  current length of request queues).  As other performance measurement
  and evaluation tools are developed both within and external to the
  DIET project, we may also create access functions to enable such
  information to be incorporated in the context of the plugin
  scheduler.
\item \textbf{Enhanced aggregation methods}: The plugin scheduler
  implemented in the current release enables the DIET system to
  account for user-defined factors in the server selection process.
  However, the priority aggregation method is fairly rudimentary and
  lacks the power to express many imaginable comparison mechanisms.
  We plan to investigate methods to embed code into DIET agents
  (e.g.,~a simple expression interpreter) in a manner that is secure
  and that preserves performance.
\end{itemize}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% \end{document}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
