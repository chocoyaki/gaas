%****************************************************************************%
%* DIET User's Manual workflow chapter file                                 *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - Abdelkader Amar (Abdelkader.Amar@ens-lyon.fr)                       *%
%*    - Raphael Bolze (Raphael.Bolze@ens-lyon.fr)                           *%
%*    - Benjamin Isnard (Benjamin.Isnard@ens-lyon.fr)                       *%
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%

\chapter{Workflow management in \textsc{Diet}}

\section{Quick start}


\paragraph{Requirements and compilation}

The workflow supports in \diet needs the following:

\begin{itemize}
\item The Xerces library: the XML handling code is written with
  Xerces-C++ using the provided DOM API.
\item Enable the workflow support when compiling \diet. In order to build \diet with workflow support using \textit{cmake}, two
configuration parameters need to be set:

\begin{itemize}
\item \texttt{DIET\_USE\_WORKFLOW} as follow: \texttt{-DDIET\_USE\_WORKFLOW:BOOL=ON}
\item \texttt{XERCES\_DIR}: defines the path to Xerces installation directory.
  (for example \texttt{-DXERCES\_DIR:PATH=/usr/local/xerces})
\end{itemize}

This is an example of generating command line:

\verb|cmake .. -DMAINTAINER_MODE:BOOL=ON -DOMNIORB4_DIR=/usr/local/omniORB \|

\verb|      -DDIET_USE_WORKFLOW:BOOL=ON \|

\verb|      -DXERCES_DIR=/usr/local/xerces|


\paragraph{}
Workflow support was tested in the following configurations:

\begin{itemize}
\item gcc version 4.0.2 and higher.
\item \textit{Xerces} 2.7.
\end{itemize}
\end{itemize}

\paragraph{Executing the examples}
%\label{sec:wf_examples}

The directory \texttt{examples/workflow} includes some examples of
workflows.  You can find a simple workflow (see
Figure~\ref{fig:example1}) in the file \texttt{xml/scalar.xml} and you
can test it with the following command:

\verb|./scalar_client local_client.cfg scalar.xml |

You need to have a running \diet platform with the needed services. You
can launch separate SeDs (\textit{succ}, \textit{double}, \textit{sum}
and \textit{square}) or a single SeD that includes all the needed
services (read Chapter~\ref{ch:server} for more details).

\begin{figure}[htbp]
  \centering
  \includegraphics[keepaspectratio,width=0.4\linewidth]{fig/wf_example1}
  \caption{Workflow example}
  \label{fig:example1}
\end{figure}

\section{Software architecture}

The workflow support in \diet provides two kind of architectures. 

\begin{itemize}
   \item The first one provides a workflow manager in the client side.
   \item The second one use a special agent called the \madag which is
     responsible to communicate with the \textit{Master Agent} of the
     platform. Two modes are available:
     \begin{description}
     \item{First mode:} \madag provides an ordering and mapping for
       workflow execution.
     \item{Second mode:} \madag provides only an ordering for the
       workflow execution.  
     \end{description}
\end{itemize}

\subsection{Architecture 1: Workflow manager inside the client}
\label{sec:archi1}

In this scheme (Figure~\ref{fig:archi1}), the handling of workflow is
done by the client, and the execution don't require an \madag. The
execution steps are~:

\begin{enumerate}
\item The client read and process the workflow description; a Directed
  Acyclic Graph (DAG) structure is created.
\item The client sends the problem descriptions to the
  Master Agent to check if all services are available.
\item If all services are available, the client start the workflow
  execution. By default a random scheduler is used to execute the DAG,
  so only data dependencies are used to define the execution order.
  In this mode, since all scheduling operation are done in the client
  side, we can use a customized scheduler. The client programmer can
  write a personal scheduler which must be a
  \textit{AbstractScheduler} subclass and implements the
  \textit{execute} method (for more details see the
  Section~\ref{sec:wf_sched}).
\item If the execution was successful, the client can retrieve the
  results.
\end{enumerate}

To use this execution mode, nothing needs to be configured except that
the client configuration file must not include a \texttt{MADAGNAME} parameter.

\begin{figure}[htbp]
  \centering
  \includegraphics[keepaspectratio,width=0.7\linewidth]{fig/wf_archi1}
  \caption{Architecture 1 : workflow manager inside the client}
  \label{fig:archi1}
\end{figure}



\subsection{Architecture 2: \madag Workflow manager}
\label{sec:archi2}

The second architecture (Figure~\ref{fig:archi2}) of workflow
management in \diet use an additional entity called the \madag to
handle the workflow. This agent can work in two modes, in the first it
defines a complete scheduling of the workflow (ordering and mapping),
while in the second it defines only an ordering for the workflow
execution. In the second mode the mapping is done in the next step by
the client which asks the Master Agent to find the server where
 to execute the workflow services.


To use the \madag, the client configuration file must include
the parameter \texttt{MADAGNAME} with the appropriate name.

\paragraph{First mode : the \madag performs the complete scheduling}

\begin{enumerate}
\item The client sends the workflow description to the \madag.
\item The MA\_dAG request the platform Master Agent to check if all
  services are available.
\item If the workflow can be executed, the \madag defines a mapping and
  ordering and send it back to the client. Currently, the ordering is
  random like in the first architecture, while the mapping use a round
  robin policy.
\item The client start the workflow execution and retrieve the results
  if the execution was successful.
\end{enumerate}

This mode is the default mode when the \texttt{MADAGNAME} is set in
the configuration file. The client can ensure this mode by the method
\texttt{set\_ma\_dag\_sched}. \fixme{How ?}

\paragraph{Second mode : the \madag provides only an ordering}

This mode is similar to the previous one, except that the \madag
provides only an execution order (or a priority tag for each node),
the mapping is done when the client tries to execute each service, so
the server is the one chosen by the Master Agent when requested by the
client. To use this mode, the client needs to set the first scheduler for
\madag using to the method \texttt{set\_ma\_dag\_sched(0)}. 

\begin{figure}[htbp]
  \centering
  \includegraphics[keepaspectratio,width=0.7\linewidth]{fig/wf_archi2}
  \caption{Architecture 2 : The \madag as an external workflow manager}
  \label{fig:archi2}
\end{figure}




\section{Client API}


\subsection{Structure of client program}
\label{sec:client_prg}

The structure of a client program is very close to the structure of
usual \diet client. The general algorithm is as follow:

\begin{verbatim}
diet_initialize

create the workflow profile

call the method diet_wf_call

if success retrieve the results

free the workflow profile

diet_finalize
\end{verbatim}

The table~\ref{tab::wf_api} shows a description of the different
methods provided by the \diet workflow API. 

\begin{table}[htbp]
  \centering
  \begin{tabular}[htbp]{|p{8cm}|p{7.5cm}|}\hline
    Workflow function & Description \\\hline
    %
    \texttt{diet\_wf\_desc\_t*  \newline
      diet\_wf\_profile\_alloc(const char* wf\_file\_name);} 
    &
    allocate a workflow profile to be used for a workflow submission.\newline
    \textit{wf\_file\_name} : the file name containing the workflow XML description.
    \\\hline
    % 
    \texttt{void  \newline
      diet\_wf\_profile\_free(diet\_wf\_desc\_t * profile);} 
    &
    free the workflow profile.
    \\\hline
    %
    \texttt{diet\_error\_t \newline
      diet\_wf\_call(diet\_wf\_desc\_t* wf\_profile);} 
    &
    execute the workflow associated to profile \textit{wf\_profile}.
    \\\hline
    %
    \texttt{int   \newline
      diet\_wf\_scalar\_get(const char * id, void** value);} 
    &
    Retrieve a workflow scalar result. \newline
    \textit{id} : the output port identifier.
    \\\hline
    % 
    \texttt{int   \newline
      diet\_wf\_string\_get(const char * id, char** value);} 
    &
    Retrieve a workflow string result. \newline
    \textit{id} : the output port identifier.
    \\\hline
    %
    \texttt{int    \newline
      diet\_wf\_file\_get(const char * id, size\_t* size, char** path);
    }
    &
    Retrieve a workflow file result. \newline
    \textit{id} : the output port identifier.
    \\\hline
    % 
    \texttt{int \newline
      diet\_wf\_matrix\_get(id, (void**)value, nb\_rows, nb\_cols, order)
    }
    &
    Retrieve a workflow matrix result. \newline
    \textit{id} : the output port identifier.
    \\\hline
    % 
    \texttt{void \newline
      set\_madag\_sched(int b);}&
    Define if the client use the \madag ordering and mapping when
    executing the workflow ($b\neq1$) or just its ordering ($b=0$)
    \\\hline
    %
    \texttt{void  \newline
      set\_sched (struct AbstractWfSched * sched);}&
    Define a customized scheduler defined by the user. The Scheduler
    must be an AbstractScheduler subclass and implements the
    \textit{execute} method.
    \\\hline
    %
    \texttt{void \newline
      enable\_reordering(const char * name, int b);
    }
    & 
    enable/disable the reordering \newline
    reordering enabled (b = true) \newline
    reordering disabled (b = false)
    \\\hline
    %
    \texttt{void \newline
      void get\_all\_results();}
    &
    print all the results of the current executed workflow.
    \\\hline
    %
  \end{tabular}
  \caption{Diet workflow API}
  \label{tab::wf_api}
\end{table}


\subsection{Workflow description}
\label{sec:workflow_desc}

The workflow is described with an XML representation which is close
to \diet profile representation. In addition to profile description
(problem path and arguments), this description represents also the
data dependencies between ports (source/sink), the node identifier
(unique) and the precedences between nodes. This last information can
be removed since it can be retrieved from the dependencies between
ports, however it can be useful to define a temporal dependency
without port linking.

The general structure of this description is:

\begin{verbatim}
<dag>
  <node id="..." path="...">
    <arg name="..." type="........" value=".."/>
    <in name="..." type="........" source="......."/>
    <out name="...." type="........" sink="......"/>
    <out name="...." type="........" sink="......"/>
  </node>
  ....
\end{verbatim}

The name argument represents the identifier of the port. To use it to
define a \textit{source} or a \textit{sink} value, it must be prefixed
with the node id. For example if the source of the input port
\textit{in3} is the port \textit{out2} of the node \textit{n1}, than
the element must be described as follow:

\begin{verbatim}
    <in name="in3" type="DIET_INT" source="n1#out2"/>
\end{verbatim}

The example shown in Figure~\ref{fig:example1} can be represented by
this XML description:

\begin{verbatim}
<dag>
  <node id="n1" path="succ">
    <arg name="in1" type="DIET_INT" value="56"/>
    <out name="out1" type="DIET_INT" sink="n2#in2"/>
    <out name="out2" type="DIET_INT" sink="n3#in3"/>
  </node>
  <node id="n2" path="double">
    <prec id="n1"/>
    <in name="in2" type="DIET_INT" source="n1#out1"/>
    <out name="out3" type="DIET_INT" sink="n4#in4"/>
  </node>
  <node id="n3" path="double">
    <prec id="n1"/>
    <in name="in3" type="DIET_INT" source="n1#out2"/>
    <out name="out4" type="DIET_INT" sink="n4#in5"/>
  </node>
  <node id="n4" path="sum">
    <prec id="n2"/>
    <prec id="n3"/>
    <in name="in4" type="DIET_INT" source="n2#out3"/>
    <in name="in5" type="DIET_INT" source="n3#out4"/>
    <out name="out4" type="DIET_INT"/>
  </node>
</dag>
\end{verbatim}

\subsection{Examples}
\label{sec:examples}


\subsubsection{Example 1 : the simplest example}
\label{sec:ex1}

This examples represents the basic client code to execute a workflow.
The line 26 indicates that the workflow output is a double value named
\verb|n4#out4|. The example shown in Figure~\ref{fig:example1} can be
fully (execution and result retrieving) executed with this client.

\begin{lstlisting}{1}
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>

#include "DIET_client.h"

int main(int argc, char* argv[])
{
  diet_wf_desc_t * profile;
  char * fileName;
  long * l; 
  if (argc != 3) {
    fprintf(stderr, "Usage: %s <file.cfg> <wf_file> \n", argv[0]);
    return 1;
  }
  
  if (diet_initialize(argv[1], argc, argv)) {
    fprintf(stderr, "DIET initialization failed !\n");
    return 1;
  } 
  fileName = argv[2];
  profile = diet_wf_profile_alloc(fileName);
  if (!diet_wf_call(profile)) {
    printf("get result = %d ", diet_wf_scalar_get("n4#out4", &l));
    printf("%ld\n", (long)(*l)); 
  }
  diet_wf_free(profile);
  return 0;
}
\end{lstlisting}

\paragraph{Example 2 :  Use the MA DAG modes}

This example is similar to the previous one but the user can specify
which mode he wants to use by command line options \verb|-madag_sched|
(the default) or \verb|-notmadag_sched|.

\begin{lstlisting}{2}
#include <string.h>
#include <unistd.h>
#include <stdlib.h>
#include <stdio.h>
#include <sys/stat.h>
#include "DIET_client.h"

void usage(char * s) {
  fprintf(stderr, "Usage: %s <file.cfg> <wf_file> [option]\n", s);
  fprintf(stderr, "option = -madag_sched | -notmadag_sched\n");
  exit(1);
}
int checkUsage(int argc, char ** argv) {
  if ((argc != 3) && (argc != 4)) {
    usage(argv[0]);
  }
  if (argc == 4) {
    if (strcmp(argv[3], "-madag_sched") && 
	strcmp(argv[3], "-notmadag_sched")) {
      usage(argv[0]);
    }
  }
  return 0;
}

int main(int argc, char* argv[])
{
  diet_wf_desc_t * profile;
  char * fileName;
  long * l; 
  checkUsage(argc, argv);
  if (diet_initialize(argv[1], argc, argv)) {
    fprintf(stderr, "DIET initialization failed !\n");
    return 1;
  } 
  fileName = argv[2];
  if (argc == 4)
    set_madag_sched(!strcmp(argv[3], "-madag_sched"));
  profile = diet_wf_profile_alloc(fileName);
  if (!diet_wf_call(profile)) {
    printf("get result = %d ", diet_wf_scalar_get("n4#out4", &l));
    printf("%ld\n", (long)(*l)); 
  }
  diet_wf_free(profile);
  return 0;
}
\end{lstlisting}


\section{Scheduling}
\label{sec:wf_sched}

\subsection{Available schedulers}

The available schedulers are:

\begin{itemize}
\item In the client: a round robbin and HEFT scheduler.
\item In the \madag: a round robbin, HEFT, and FOFT (Fairness On
  Finish Time: in multiworkflow support -experimental-).
\end{itemize}

\subsection{Writing a new scheduler}

The workflow scheduler of the client is different little bit from the
\madag one. To write a new scheduler you need \diet sources. The
following two section show how to develop your own scheduler and how
to plug it in your client or in the \madag.

\paragraph{Client scheduler}

To write a new workflow scheduler for your \diet client you need to
create a derived class of the base abstract class
\textit{AbstractWfSched}. The main function of the scheduler (the SeDs
mapping) must be placed in the pure virtual function \textit{execute}.
These are the steps to follow:

\begin{enumerate}
\item Write a subclass of \textit{AbsWfSched} abstract class. The
  virtual method \textit{execute} needs to be implemented.
\item Create a c++ file where you can put the following code:
\begin{verbatim}
extern "C" {
  void set_my_personal_sched() {
    Personal_WfSched * mySched = new Personal_WfSched();
    set_sched(mySched);
  }
}
\end{verbatim}
\item In your client source code, call the method
  \textit{set\_my\_personal\_sched} before executing the
  \textit{diet\_wf\_call}.
\item Link the previous c++ object code to you \diet client.
\end{enumerate}

