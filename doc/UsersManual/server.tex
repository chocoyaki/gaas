%****************************************************************************%
%* DIET User's Manual server chapter file                                   *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - Eddy CARON (Eddy.Caron@ens-lyon.fr)                                 *%
%*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       *%
%*    - Georg Hoesh (Georg.Hoesh@ens-lyon.fr)                               *%
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%
%* $Id$
%* $Log$
%* Revision 1.5  2004/01/21 00:25:13  ecaron
%* Add suggestions from Holly Dail. Thanks !
%*
%* Revision 1.4  2004/01/05 23:17:00  ecaron
%* Building a server application for DIET 1.0
%*
%* Revision 1.3  2003/12/15 13:49:36  ecaron
%* Pointer correction into the diet_scalar_desc_set call
%*
%* Revision 1.2  2003/12/10 17:44:34  ghoesch
%* added the convertor explanation
%*
%* Revision 1.1  2003/09/09 12:38:20  pcombes
%* Reorganization of doc: UM becomes UsersManual.
%*
%* Revision 1.12  2003/06/16 17:41:01  pcombes
%* Fix some mistakes on file names.
%*
%* Revision 1.11  2003/06/02 13:47:05  pcombes
%* Fix footnotesize.
%*
%* Revision 1.10  2003/05/23 09:23:35  pcombes
%* Add suggestions from Jean-Yves. Thanks !
%*
%* Revision 1.9  2003/05/15 14:17:58  pcombes
%* UM 0.7
%*
%* Revision 1.6  2003/01/24 16:58:54  pcombes
%* UM 0.6.4
%*
%* Revision 1.4  2003/01/21 12:17:02  pcombes
%* Update UM to API 0.6.3, and "hide" data structures.
%*
%* Revision 1.2  2003/01/13 12:09:00  pcombes
%* UM: client part complete for users's day ...
%****************************************************************************%

\chapter{Building a server application}
\label{ch:server}

A DIET server program is the link between the DIET SeD and the libraries that
implement the service to offer.

\section{Structure of the program}
\label{sec:sv_struct}

As for the client side, the DIET SeD is a library. So the server developer needs
to define the \texttt{main} function. Within the \texttt{main}, the DIET server
will be launched with a call to \texttt{diet\_SeD} which will never return
(except if some errors occur). The complete server side interface is described
in the \texttt{$<$install\_dir$>$/include} files \texttt{DIET\_data.h} (see
Chapter \ref{ch:data}) and \texttt{DIET\_server.h}. Don't forget to include the \texttt{DIET\_server.h} (\texttt{DIET\_server.h} includes \texttt{DIET\_data.h}) at the beginning of your server source code :

{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

#include "DIET_server.h"
\end{verbatim}
}

The second step is to define a function whose prototype is ``DIET-normalized''
and which will be able to convert the function into the library function prototype.
Let us consider a library function with the following prototype:
{\footnotesize
\begin{verbatim}
int service(int arg1, char *arg2, double *arg3);
\end{verbatim}
}

This function cannot be called directly by DIET, since such a prototype is hard
to manipulate dynamically. The user must define a ``solve'' function whose
prototype only consists of a \texttt{diet\_profile\_t}.
This function will be called by the DIET SeD through a pointer.
{\footnotesize
\begin{verbatim}
int solve_service(diet_profile_t *pb)
{
   int     arg1;
   char   *arg2;
   double *arg3;

   diet_scalar_get(diet_parameter(pb,0), &arg1, NULL);
   diet_string_get(diet_parameter(pb,1), &arg2, NULL, NULL);
   diet_scalar_get(diet_parameter(pb,2), &arg3, NULL);
   return service(arg1, arg2, arg3);
}
\end{verbatim}
}

Several API functions are useful to help the user write this ``solve''
function, particularly for getting IN arguments as well as setting OUT ones.

\subsubsection*{Getting IN, INOUT and OUT arguments}

The \texttt{diet\_*\_get} functions defined in \texttt{DIET\_data.h} are still
usable here. Do not forget that the necessary memory space for OUT arguments is
allocated by DIET. So the user should call the \texttt{diet\_*\_get} functions
to retrieve the pointer to the zone his/her program should write to.

\subsubsection*{Setting INOUT and OUT arguments}

To set INOUT and OUT arguments, use the \texttt{diet\_*\_desc\_set} defined
in \texttt{DIET\_server.h}, because they are helpful for writing ``solve''
functions only. Using these functions, the server developer must keep in
mind the fact that he cannot alter the memory space pointed by value
fields on the server. Indeed, this would make DIET confused about how to
manage the data.{\footnote{And the server developer should not be confused
    by the fact that \texttt{diet\_scalar\_desc\_set} uses a value, since
    scalar values are copied into the data descriptor.}  {\footnotesize
\begin{verbatim}
/**
 * If value              is NULL,
 * or if order              is DIET_MATRIX_ORDER_COUNT,
 * or if nb_rows or nb_cols is 0,
 * or if path               is NULL,
 * then the corresponding field is not modified.
 */

int
diet_scalar_desc_set(diet_data_t* data, void* value);

// No use of diet_vector_desc_set: size should not be altered by server

// You can alter nb_r and nb_c, but the total size must remain the same
int
diet_matrix_desc_set(diet_data_t* data,
                     size_t nb_r, size_t nb_c, diet_matrix_order_t order);

// No use of diet_string_desc_set: length should not be altered by server

int
diet_file_desc_set(diet_data_t* data, char* path);
\end{verbatim}
}


\section{Server API}
\label{sec:svAPI}


\subsubsection*{Defining services}

First, declare the service(s) that will be offered.{\footnote{It is possible to
  declare several services for one single SeD.}
Each service is described by a profile description called \texttt{diet\_profile\_desc\_t}, since the service does not specify the sizes of the data.
The \texttt{diet\_profile\_desc\_t} type is defined in \texttt{DIET\_server.h},
and is very similar to \texttt{diet\_profile\_t}. The difference is that the
prototype is described with the generic parts of \emph{diet\_data\_desc} only,
whereas the client description uses full \emph{diet\_data}.
{\footnotesize
\begin{verbatim}
file DIET_data.h:
     struct diet_data_generic {
       diet_data_type_t type;
       diet_base_type_t base_type;
     };

file DIET_server.h:
     typedef struct diet_data_generic diet_arg_desc_t;

     typedef struct {
       char*            path;
       int              last_in, last_inout, last_out;
       diet_arg_desc_t* param_desc;
     } diet_profile_desc_t;

diet_profile_desc_t* diet_profile_desc_alloc(const char* path,
                        int last_in, int last_inout, int last_out);
int diet_profile_desc_free(diet_profile_desc_t* desc);

diet_profile_desc_t *diet_profile_desc_alloc(int last_in, int last_inout, int last_out);

int diet_profile_desc_free(diet_profile_desc_t *desc);
\end{verbatim}
}

Each profile can be allocated with \texttt{diet\_profile\_desc\_alloc} with the
same semantics as for \texttt{diet\_profile\_alloc}. Every argument of the
profile will then be set with \texttt{diet\_generic\_desc\_set} defined in
\texttt{DIET\_server.h}.

\subsubsection*{Declaring services}

Every service defined has to be added in the service table before the server is
launched. The complete service table API is defined in \texttt{DIET\_server.h}:
{\footnotesize
\begin{verbatim}
typedef int (* diet_solve_t)(diet_profile_t *);
int diet_service_table_init(int max_size);
int diet_service_table_add(diet_profile_desc_t *profile,
                           diet_convertor_t    *cvt,
                           diet_solve_t         solve_func);
void diet_print_service_table();
\end{verbatim}
}

The parameter \texttt{diet\_solve\_t solve\_func} is the type of the
\texttt{solve\_service} function: a function pointer used by DIET to launch the
computation.

The parameter \texttt{diet\_convertor\_t *cvt} is to be used in
combination with FAST, and is there to allow profile conversion (for
multiple services, or when differences occur between the DIET and the
FAST profile). This is not an easy task and will therefore be
explained separately in the next paragraphs.

\subsubsection*{Using convertors}

The service profiles offered by DIET are sometimes not
understandable by the service implementations. To solve this problem,
a convertor processes each profile before it is passed to the
implementation. This is mainly used to
hide the implementation specific profile of a service from
the user. It allows different servers to declare the same
service with the same profile using different implementations
of the service. As FAST relies on the path of the service the
convertor can also change the path of the declared profile to
enable a correct evaluation of the incoming requests by FAST.
If no convertor is passed when declaring a new service, a
default convertor is assigned to it that does not change its
profile nor its path.

To translate a profile, the convertor defines a new
destination profile with a new path. It then chooses for
each argument of the new profile a predefined function
to compute this argument from the source profile. This
allows the following operations:

\begin{itemize}
\item Permutation of arguments \\
This is done implicitly by specifying which argument in the source
profile corresponds to which argument in the destination profile.
\item Copy of arguments\\
Arguments can be simply used by applying the \texttt{DIET\_CVT\_IDENTITY}
function. If the same source argument corresponds to two
destination arguments it is automatically copied.
\item Creation of new arguments\\
New arguments can either contain static values or the properties
of existing arguments. To create a new static value, the index for
the source argument must be invalid (e.g. -1) and the arg parameter
must be set to the static argument. To extract a property of an 
existing argument, other functions than \texttt{DIET\_CVT\_IDENTITY} must be
applied. The result of this function will
then be used as the value for the destination argument. Corresponding to
the DIET datatypes, the following functions exist: \\
\begin{itemize}
\item{\texttt{DIET\_CVT\_IDENTITY}} Copy the argument
\item{\texttt{DIET\_CVT\_VECT\_SIZE}} Get the size of a vector
\item{\texttt{DIET\_CVT\_MAT\_NB\_ROW}} Get the number of rows of a matrix
\item{\texttt{DIET\_CVT\_MAT\_NB\_COL}} Get the number of columns of a matrix
\item{\texttt{DIET\_CVT\_MAT\_ORDER}} Get the order of a matrix
\item{\texttt{DIET\_CVT\_STR\_LEN}} Get the length of the string
\item{\texttt{DIET\_CVT\_FILE\_SIZE}} Get the size of the file
\end{itemize}
Only the \texttt{DIET\_CVT\_IDENTITY} function can be applied to any argument.
All other functions can only operate on one type of argument but this
should be self explanation.

\end{itemize}

\noindent Lets look a short example:
\footnotesize
\begin{verbatim}

/**
 * Example 1
 * Assume we declared a profile (INOUT MATRIX) with the path 'solve_T'.
 * This profile will be called by the clients. Our implementation expects
 * a profile (IN INT, IN INT, INOUT MATRIX). This profile is known to
 * FAST with the path 'T_solve'.
 * We will write a convertor that changes the name and extracts the 
 * matrix's dimensions.
 */
    // declare a new convertor with 2 IN, 1 INOUT and 0 OUT arguments
    cvt = diet_convertor_alloc("T_solve", 0, 1, 1);

    // apply the function DIET_CVT_MAT_NB_ROW to determine the
    // 0th argument of the converted profile. The function's
    // argument is the 0th argument of the source profile. As it
    // is an IN argument, the last parameter is not important.
    diet_arg_cvt_set(&(cvt->arg_convs[0]), DIET_CVT_MAT_NB_ROW, 0, NULL, 0);

    // apply the function DIET_CVT_MAT_NB_COL to determine the
    // 1st argument of the converted profile. The function's
    // argument is the 0th argument of the source profile. As it
    // is a IN argument, the last parameter is not important.
    diet_arg_cvt_set(&(cvt->arg_convs[1]), DIET_CVT_MAT_NB_COL, 0, NULL, 0);

    // apply the function DIET_CVT_IDENTITY to determine the
    // 2nd argument of the converted profile. The function's
    // argument is the 0th argument of the source profile and
    // it will be written back to the 0th argument of the source
    // profile when the call has finished.
    diet_arg-cvt_set(&(cvt->arg_convs[2]), DIET_CVT_IDENTITY, 0, NULL, 0);

    // NOTE: The last line could also be written as:
    //diet_arg_cvt_short_set(&(cvt->arg_convs[2]), 0, NULL);

    // add the service using our convertor
    diet_service_table_add(profile, cvt, solve_T);

    // free our convertor
    diet_convertor_free(cvt);
\end{verbatim}
\normalsize

\noindent More examples on how to create and use convertors are given in the
files \\
'\texttt{examples/dmat\_manips/server.c}' and '\texttt{examples/BLAS/server.c}'.


\section{Example}
\label{sec:sv_ex}

Let us consider the same example as in Chapter \ref{ch:client}, where
a function \texttt{scal\_mat\_prod} performs the product of a matrix
by a scalar and times the computation: {\footnotesize
\begin{verbatim}
int scal_mat_prod(double alpha, double *M, int nb_rows, int nb_cols, float *time);
\end{verbatim}
}
Our program will first define the solve function that consists of the link
between DIET and this function. Then, the \texttt{main} defines one service and
adds it in the service table with its associated solve function.
{\footnotesize
\begin{verbatim}
#include "DIET_server.h"
#include "scal_mat_prod.h"

int scal_mat_prod(diet_profile_t *pb)
{
  double alpha;
  double *M;
  float  time;
  int    m, n, res;
  /* Get arguments */
  diet_scalar_get(diet_parameter(pb,0), &alpha, NULL);
  diet_matrix_get(diet_parameter(pb,1), &M, NULL, &m, &n, NULL);
  /* Launch computation */
  res = scal_mat_prod(alpha, M, m, n, &time);
  /* Set OUT arguments */
  diet_scalar_desc_set(diet_parameter(pb,2), &time);



  return res;
}

int main(int argc, char* argv[])
{
  diet_profile_desc_t *profile;
  
  /* Initialize table with maximum 1 service */
  diet_service_table_init(1);
  /* Define smprod profile */
  profile = diet_profile_desc_alloc("smprod",0, 1, 2);
  diet_generic_desc_set(diet_param_desc(profile,0), DIET_SCALAR, DIET_DOUBLE);
  diet_generic_desc_set(diet_param_desc(profile,1), DIET_MATRIX, DIET_DOUBLE);
  diet_generic_desc_set(diet_param_desc(profile,2), DIET_SCALAR, DIET_FLOAT);
  /* Add the service (the profile descriptor is deep copied) */
  diet_service_table_add(profile, NULL, solve_smprod);
  /* Free the profile descriptor, since it was deep copied. */
  diet_profile_desc_free(profile);

  /* Launch the SeD: no return call */
  diet_SeD("SeD.cfg", argc, argv);

  /* Dead code */
  return 0;
}
\end{verbatim}
}


\section{Compilation}
\label{sec:sv_comp}


After compiling his/her server program, the user must link it with the DIET
libraries, the CORBA libraries, and the FAST libraries if DIET was compiled to
use FAST. The easiest way to compile a program using DIET with all
necessary flags and link with the right libraries is to trust the
\texttt{Makefile.inc} available in \texttt{$<$include\_dir$>$/include}, and
include it at the beginning of the program makefile.

The \texttt{Makefile.inc} defines the variables:
\begin{itemize}
\item \texttt{CC} and \texttt{CCFLAGS} that are to be used if you compile C
 code,
\item \texttt{CXX} and \texttt{CXXFLAGS} that are to be used if you compile C++
  code,
\item \texttt{DIET\_SERVER\_LIBS} that defines the CORBA and DIET SeD libraries.
\end{itemize}

For our C example, the Makefile should be something like:
{\footnotesize
\begin{verbatim}
include <install_dir>/Makefile.inc

server.o: server.c
          $(CC) -c $< $(CCFLAGS) -o $@

server:   server.o
          $(CC) $< $(CCFLAGS) $(DIET_SERVER_LIBS) -o $@
\end{verbatim}
}

%%% Local Variables: 
%%% mode: latex
%%% TeX-master: t
%%% fill-column: 75
%%% ispell-dictionary: american
%%% mode: flyspell
%%% End: 

% LaTeX keywords :
% LocalWords:  itemize Macros plain utils setspace url wrapfig
% LocalWords:  inputenc fontenc french babel dvips epsfig twoside enumerate
% LocalWords:  LocalWords LaTeX keywords fill-column TeX-master End flyspell
% LocalWords:  american

