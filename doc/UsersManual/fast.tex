%****************************************************************************%
%* DIET User's Manual plugin scheduler chapter file                         *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - ?
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%

\chapter{Performances prediction with FAST}
\label{chapter:fast}

%\section{Introduction to FAST}

This chapter deals with FAST, the performances prediction module that
can be interrogated by the DIET system. It is non-mandatory but if you want
DIET to be able to use the power of FAST estimations, this chapter also
describes how to build the FAST-enable server.

%====[ FAST: FAST AGENT'S SYSTEM TIMER ]=======================================
\section{FAST: Fast Agent's System Timer}
\label{sec:FAST}

FAST \cite{Qui02} is a tool for dynamic performance forecasting in a
Grid environment. As shown in Figure~\ref{fig:fast-overview}, FAST is
composed of several layers and relies on low-level software. First it
uses a network and CPU monitoring software to handle dynamically
changing resources, like workload or bandwidth.  FAST uses the Network
Weather Service (NWS)~\cite{WSH99}, a distributed system that
periodically monitors and dynamically forecasts the performance of
various network and computational resources. The resource
availabilities acquisition module of FAST uses and enhances NWS.
Indeed, if there is no direct NWS monitoring between two machines,
FAST automatically searches for the shortest path between them in the
graph of monitored links. It estimates the bandwidth as the minimum of
those in the path and the latency as the sum of those measured. This
allows for the availability of more predictions when DIET is deployed
over a hierarchical network.

\begin{figure}[htb]
  \begin{center}
    \resizebox{.75\linewidth}{!}{\includegraphics{fig/FAST.eps}}
    \caption{FAST overview}
    \label{fig:fast-overview}
  \end{center}
\end{figure}

In addition to the system availabilities, FAST can also forecast the
time and space needs of computational routines, depending on both the
parameter set and the machine where the computation would take place.
For this, FAST benchmarks the routines at installation time on each
machine for a representative set of parameters. After polynomial data
fitting, the results are stored in an LDAP tree.  The user API of FAST
is composed of a small set of functions that combine resource
availabilities and routine needs from low-level software to produce
ready-to-use values.  These results can be combined into analytical
models by the parallel extension~\cite{CS02} to forecast execution
times of parallel routines.

Thus DIET components, as any FAST client, can access information like
the time needed to move a given amount of data between two SeDs, the
time to solve a problem with a given set of computational resources
managed by a SeD, or the combination of these two quantities.\\

For more details about FAST, please read the FAST Reference
Manual~\footnote{\url{http://graal.ens-lyon.fr/FAST/docs}}.

\section{Building a server application with FAST}

The performances prediction is performed in the DIET SeD, thus, no
modification has to be done in the client application part.

If DIET was compiled  with the necessary options to use FAST for
performances prediction (see page~\pageref{fast_compil}), the server
part of the application has do be adaptated. As introduced in
section~\ref{sec:sv_comp}, in that case, the role of convertors is
important.

In the next subsections, we will explain the convertors and see how it
should be implemented in an example.

\subsection{Using convertors}

The service profiles offered by DIET are sometimes not
understandable by the service implementations. To solve this problem,
a convertor processes each profile before it is passed to the
implementation. This is mainly used to
hide the implementation specific profile of a service from
the user. It allows different servers to declare the same
service with the same profile using different implementations
of the service. As FAST relies on the path of the service the
convertor can also change the path of the declared profile to
enable a correct evaluation of the incoming requests by FAST.
If no convertor is passed when declaring a new service, a
default convertor is assigned to it that does not change its
profile nor its path.

To translate a profile, the convertor defines a new
destination profile with a new path. It then chooses for
each argument of the new profile a predefined function
to compute this argument from the source profile. This
allows the following operations:

\begin{description}
\item{\textbf{Permutation of arguments}}. This is done implicitly by
  specifying which argument in the source profile corresponds to which
  argument in the destination profile.
\item{\textbf{Copy of arguments}}. Arguments can be simply used by
  applying the \texttt{DIET\_CVT\_IDENTITY} function. If the same
  source argument corresponds to two destination arguments it is
  automatically copied.
\item{\textbf{Creation of new arguments}}. New arguments can either
  contain static values or the properties of existing arguments. To
  create a new static value, the index for the source argument must be
  invalid (e.g. -1) and the arg parameter must be set to the static
  argument. To extract a property of an existing argument, other
  functions than \texttt{DIET\_CVT\_IDENTITY} must be applied. The
  result of this function will then be used as the value for the
  destination argument.  Corresponding to the DIET datatypes, the
  following functions exist: \\
\begin{itemize}
\item{\texttt{DIET\_CVT\_IDENTITY}} Copy the argument
\item{\texttt{DIET\_CVT\_VECT\_SIZE}} Get the size of a vector
\item{\texttt{DIET\_CVT\_MAT\_NB\_ROW}} Get the number of rows of a matrix
\item{\texttt{DIET\_CVT\_MAT\_NB\_COL}} Get the number of columns of a matrix
\item{\texttt{DIET\_CVT\_MAT\_ORDER}} Get the order of a matrix
\item{\texttt{DIET\_CVT\_STR\_LEN}} Get the length of the string
\item{\texttt{DIET\_CVT\_FILE\_SIZE}} Get the size of the file
\end{itemize}
Only the \texttt{DIET\_CVT\_IDENTITY} function can be applied to any
argument.  All other functions can only operate on one type of
argument but this should be self explanation.

\end{description}

\subsection{Example with convertors}

\noindent A short example is available below:
\footnotesize
\begin{verbatim}

/**
 * Example 1
 * Assume we declared a profile (INOUT MATRIX) with the path 'solve_T'.
 * This profile will be called by the clients. Our implementation expects
 * a profile (IN INT, IN INT, INOUT MATRIX). This profile is known to
 * FAST with the path 'T_solve'.
 * We will write a convertor that changes the name and extracts the 
 * matrix's dimensions.
 */
    // declare a new convertor with 2 IN, 1 INOUT and 0 OUT arguments
    cvt = diet_convertor_alloc("T_solve", 0, 1, 1);

    // apply the function DIET_CVT_MAT_NB_ROW to determine the
    // 0th argument of the converted profile. The function's
    // argument is the 0th argument of the source profile. As it
    // is an IN argument, the last parameter is not important.
    diet_arg_cvt_set(&(cvt->arg_convs[0]), DIET_CVT_MAT_NB_ROW, 0, NULL, 0);

    // apply the function DIET_CVT_MAT_NB_COL to determine the
    // 1st argument of the converted profile. The function's
    // argument is the 0th argument of the source profile. As it
    // is a IN argument, the last parameter is not important.
    diet_arg_cvt_set(&(cvt->arg_convs[1]), DIET_CVT_MAT_NB_COL, 0, NULL, 0);

    // apply the function DIET_CVT_IDENTITY to determine the
    // 2nd argument of the converted profile. The function's
    // argument is the 0th argument of the source profile and
    // it will be written back to the 0th argument of the source
    // profile when the call has finished.
    diet_arg-cvt_set(&(cvt->arg_convs[2]), DIET_CVT_IDENTITY, 0, NULL, 0);

    // NOTE: The last line could also be written as:
    //diet_arg_cvt_short_set(&(cvt->arg_convs[2]), 0, NULL);

    // add the service using our convertor
    diet_service_table_add(profile, cvt, solve_T);

    // free our convertor
    diet_convertor_free(cvt);
\end{verbatim}
\normalsize

\noindent More examples on how to create and use convertors are given in the
files \\
'\texttt{examples/dmat\_manips/server.c}' and '\texttt{examples/BLAS/server.c}'.

