%****************************************************************************%
%* DIET User's Manual client chapter file                                   *%
%*                                                                          *%
%*  Author(s):                                                              *%
%*    - Eddy CARON      (Eddy.Caron@ens-lyon.fr)                            *%
%*    - Philippe COMBES (Philippe.Combes@ens-lyon.fr)                       *%
%*    - Christophe Pera (Christophe.Pera@ens-lyon.fr)                       *%
%*                                                                          *%
%* $LICENSE$                                                                *%
%****************************************************************************%
%* $Id$
%* $Log$
%* Revision 1.17  2010/01/21 14:05:58  bdepardo
%* DIET -> \diet
%* SeD -> \sed
%* GoDIET -> \godiet
%*
%* Revision 1.16  2008/07/11 10:11:53  ecaron
%* - Ajout def API (un user a demandé)
%* - Pas mal de modifications sur le chapitre des workflows
%* 	* Corrections
%* 	* Prises en compte des remarques de Brice
%* - Fixme pour Benjamin corriger la vision 2 archi -> 1 archi
%*
%* Revision 1.15  2006/11/15 22:36:50  eboix
%*   Documentation concerning user compilation updated. --- Injay2461
%*
%* Revision 1.14  2005/07/12 21:44:28  hdail
%* - Correcting small problems throughout
%* - Modified deployment chapter to have a real section for deploying via GoDIET
%* - Adding short xml example without the comments to make a figure in GoDIET
%*   section.
%*
%* Revision 1.13  2005/06/27 08:59:41  hdail
%* Updating interfaces to agree with current versions and adding memory cleanup
%* to end of example programs.
%*
%* Revision 1.12  2005/06/14 08:15:40  ecaron
%* Typo
%*
%* Revision 1.11  2004/07/08 15:59:10  mcolin
%* correct the asynchronous example from the tutorial and user manual
%* FIXME :
%*  - still a bug with the INOUT parameter : the matrix is not modified
%*  - User Manuel [5.1] : the first example service/solve_service doesn't
%*  match with the actual version of DIET (pb with pointer and diet_string_get
%*  which doesn't exist)
%*
%* Revision 1.10  2004/02/10 00:44:24  ecaron
%* Add suggestions from Christophe Pera. Thanks !
%*
%* Revision 1.9  2004/02/02 15:57:15  ecaron
%* Add suggestion from Christophe Pera. Thanks !
%*
%* Revision 1.8  2004/01/29 17:08:47  ecaron
%* Add suggestions from Frederic Desprez. Thanks !
%*
%* Revision 1.7  2004/01/27 00:21:17  ecaron
%* Add suggestions from Jean-Yves (Thanks!)
%*
%* Revision 1.6  2004/01/21 00:25:13  ecaron
%* Add suggestions from Holly Dail. Thanks !
%*
%* Revision 1.5  2004/01/07 10:27:33  cpera
%* Add asynchronous call example and useAsyncAPI config parameter.
%*
%* Revision 1.4  2004/01/05 13:06:53  ecaron
%* Update example to DIET 1.0
%****************************************************************************%

\chapter{Building a client program}
\label{ch:client}

The most difficult part of building a client program is to understand how
to describe the problem interface. Once this step is done, it is
fairly easy to build calls to \diet.

\section{Structure of a client program}
\label{sec:cl_struct}

Since the client side of \diet is a library, a client program has to define a
\texttt{main} function that uses \diet through function calls. The complete
client-side interface is described in the files
\texttt{DIET\_data.h} (see Chapter \ref{ch:data}) and
\texttt{DIET\_client.h} found in \texttt{$<$install\_dir$>$/include}.
Please refer to these two files for a complete and
up-to-date API~\footnote{Application programming interface}
description, and include at least the latter at the beginning of
your source code (\texttt{DIET\_client.h} includes \texttt{DIET\_data.h}):
{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>

#include "DIET_client.h"

int main(int argc, char *argv[])
{
  diet_initialize(configuration_file, argc, argv);
  // Successive DIET calls ...
  diet_finalize();
}
\end{verbatim}
}

The client program must open its \diet session with a call to
\texttt{diet\_initialize}, which parses the configuration file to set
all options and get a reference to the \diet Master Agent. The session
is closed with a call to \texttt{diet\_finalize}, which frees all
resources associated with this session on the client. Note that
memory allocated for all INOUT and OUT arguments brought back onto
the client during the session is not freed during
\texttt{diet\_finalize}; this allows the user to continue to use the
data, but also requires that the user explicitly free the memory.
The user must also free the memory he or she allocated for IN
arguments.

\section{Client API}
\label{sec:clAPI}

The client API follows the GridRPC definition \cite{gridRPC:02}: all
\texttt{diet\_} functions are ``duplicated'' with \texttt{grpc\_}
functions.  Both \texttt{diet\_initialize}/\texttt{grpc\_initialize}
and \texttt{diet\_finalize}/\texttt{grpc\_finalize} belong to the
GridRPC API. 
 
    A problem is managed through a \emph{function\_handle}, that
associates a server to a problem name. For compliance with GridRPC
\diet accepts \texttt{diet\_function\_handle\_init}, but the server 
specified in the call will be ignored; \diet is designed to
automatically select the best server. The structure allocation is
performed through the function
\texttt{diet\_function\_handle\_default}.

The \emph{function\_handle} returned is associated to the problem description,
its profile, in the call to \texttt{diet\_call}.

\section{Examples}
\label{sec:cl_ex}

Let us consider the same example as in Section \ref{sec:pbex}, but
for synchronous and asynchronous calls.  Here, the client
configuration file is given as the first argument on the command
line, and we decide to hardcode the matrix, its factor, and the name
of the problem.

\subsection{Synchronous call}
\texttt{smprod}
%~\footnote{Source code available in \texttt{doc/tutorial/solutions/exercise2/client\_smprod.c}} 
for scalar by matrix product.

{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "DIET_client.h"

int main(int argc, char **argv)
{
  int i;
  double  factor = M_PI; /* Pi, why not ? */
  double *matrix;        /* The matrix to multiply */
  float  *time   = NULL; /* To check that time is set by the server */

  diet_profile_t         *profile;

  /* Allocate the matrix: 60 lines, 100 columns */
  matrix = malloc(60 * 100 * sizeof(double));
  /* Fill in the matrix with dummy values (who cares ?) */
  for (i = 0; i < (60 * 100); i++) {
    matrix[i] = 1.2 * i;
  }
  
  /* Initialize a DIET session */
  diet_initialize("./client.cfg", argc, argv);

  /* Create the profile as explained in Chapter 3 */
  profile = diet_profile_alloc("smprod",0, 1, 2); // last_in, last_inout, last_out
  
  /* Set profile arguments */
  diet_scalar_set(diet_parameter(profile,0), &factor, 0, DIET_DOUBLE);
  diet_matrix_set(diet_parameter(profile,1), matrix,  0, DIET_DOUBLE, 60, 100, DIET_COL_MAJOR);
  diet_scalar_set(diet_parameter(profile,2), NULL,    0, DIET_FLOAT);
  
  if (!diet_call(profile)) { /* If the call has succeeded ... */
     
    /* Get and print time */
    diet_scalar_get(diet_parameter(profile,2), &time, NULL);
    if (time == NULL) {
      printf("Error: time not set !\n");
    } else {
      printf("time = %f\n", *time);
    }

    /* Check the first non-zero element of the matrix */
    if (fabs(matrix[1] - ((1.2 * 1) * factor)) > 1e-15) {
      printf("Error: matrix not correctly set !\n");
    }
  }

  /* Free profile */
  diet_profile_free(profile);
  diet_finalize();
  free(matrix);
  free(time);
}
\end{verbatim}
}

\subsection{Asynchronous call}
\texttt{smprod}
%~\footnote{Source code available in \texttt{doc/tutorial/solutions/exercise2/client\_smprodAsync.c}} 
for scalar by matrix product.
{\footnotesize
\begin{verbatim}
#include <stdio.h>
#include <stdlib.h>
#include <math.h>
#include "DIET_client.h"

int main(int argc, char **argv)
{
  int i, j;
  double  factor = M_PI; /* Pi, why not ? */
  size_t m, n; /* Matrix size */
  double *matrix[5];        /* The matrix to multiply */
  float  *time   = NULL; /* To check that time is set by the server */

  diet_profile_t         *profile[5];
  diet_reqID_t rst[5] = {0,0,0,0,0};

  m = 60;
  n = 100;
 
  /* Initialize a DIET session */
  diet_initialize("./client.cfg", argc, argv);

  /* Create the profile as explained in Chapter 3 */
  for (i = 0; i < 5; i++){
    /* Allocate the matrix: m lines, n columns */
    matrix[i] = malloc(m * n * sizeof(double));
    /* Fill in the matrix with dummy values (who cares ?) */
    for (j = 0; j < (m * n); j++) {
      matrix[i][j] = 1.2 * j;
    }
    profile[i] = diet_profile_alloc("smprod",0, 1, 2); // last_in, last_inout, last_out
  
    /* Set profile arguments */
    diet_scalar_set(diet_parameter(profile[i],0), &factor, 0, DIET_DOUBLE);
    diet_matrix_set(diet_parameter(profile[i],1), matrix[i],  0, DIET_DOUBLE,
                    m, n, DIET_COL_MAJOR);
    diet_scalar_set(diet_parameter(profile[i],2), NULL,    0, DIET_FLOAT);
  }
  
  /* Call Diet */
  int rst_call = 0;
  
  for (i = 0; i < 5; i++){
     if ((rst_call = diet_call_async(profile[i], &rst[i])) != 0)  
        printf("Error in diet_call_async return -%d-\n", rst_call);
     else {
       printf("request ID value = -%d- \n", rst[i]);
       if (rst[i] < 0) {
         printf("error in request value ID\n");
         return 1;
       }
     }
     rst_call = 0;
  }   

  /* Wait for Diet answers */
  if ((rst_call = diet_wait_and((diet_reqID_t*)&rst, (unsigned int)5)) != 0)
     printf("Error in diet_wait_and\n");
  else {
    printf("Result data for requestID");
    for (i = 0; i < 5; i++) printf(" %d ", rst[i]);
    for (i = 0; i < 5; i++){
      /* Get and print time */
      diet_scalar_get(diet_parameter(profile[i],2), &time, NULL);
      if (time == NULL) {
        printf("Error: time not set !\n");
      } else {
        printf("time = %f\n", *time);
      }

      /* Check the first non-zero element of the matrix */
      if (fabs(matrix[i][1] - ((1.2 * 1) * factor)) > 1e-15) {
        printf("Error: matrix not correctly set !\n");
      }
    }
  }
  /* Free profiles */
  for (i = 0; i < 5; i++){
    diet_cancel(rst[i]);
    diet_profile_free(profile[i]);
    free(matrix[i]);
  }
  free(time);
  diet_finalize();
  return 0;
}
\end{verbatim}
}

\section{Compilation}
\label{sec:cl_comp}

After compiling the client program, the user must link it with the
\diet libraries and the CORBA libraries.

\subsection{Compilation when using Makefiles}

When using Makefiles, the easiest way to compile a program using \diet
with all necessary flags and link it with the proper libraries is to
trust the \texttt{Makefile.inc} available in 
\texttt{$<$include\_dir$>$/include} by including it at the beginning
of the program makefile.

The \texttt{Makefile.inc} defines the variables:
\begin{itemize}
\item \texttt{CCFLAGS\_DIET} which contains pre-processing instructions 
to be used when you compile C code,
\item \texttt{CXXFLAGS\_DIET} which contains pre-processing instructions
to be used when you compile C++ code,
\item \texttt{DIET\_CLIENT\_LIBS} which contains the linker instructions
in otder to link your program against the \diet client library.
\item \texttt{CC} and \texttt{CXX} which contains the name of the C compiler,
respectively C++ compiler, used to compiled \diet itself and which you
might choose to compile your own programs (in order to guarantee the 
compatibility of the compilers).
\end{itemize}
\noindent
The \texttt{doc/ExternalExample} directory contains an example of
such a user Makefile, which goes:
{\footnotesize
\begin{verbatim}
# The following inclusion provides convenient make variables for compiling
# and linking against the DIET library (DIET_HOME is an environment variable
# containing the path to a DIET installation directory):
include ${DIET_HOME}/include/Makefile.inc

all: simple_client simple_server

simple_client: simple_client.c $(DIET_CLIENT_PREREQ)
        $(CXX) -g $(CXXFLAGS_DIET) $< $(DIET_CLIENT_LIBS) -o $@
simple_server: simple_server.c  $(DIET_SERVER_PREREQ)
        $(CC) -g $(CCFLAGS_DIET) $< $(DIET_SERVER_LIBS) -o $@
clean:
        rm -f simple_client simple_server

\end{verbatim}
}

Since the \texttt{doc/ExternalExample} directory also contains the
cited \texttt{simple\_server.c} and \texttt{simple\_client.c}, one
can easily test this Makefile.

\subsection{Compilation when using cmake}

The \texttt{doc/ExternalExample} directory also contains a
\texttt{CMakeFile.txt} file which illustrates the cmake way of compiling
this simple client/server example:
{\footnotesize
\begin{verbatim}
PROJECT( DIETSIMPLEEXAMPLE )

SET( CMAKE_MODULE_PATH ${DIETSIMPLEEXAMPLE_SOURCE_DIR}/Cmake )
FIND_PACKAGE( Diet )

# On success use the information we just recovered:
INCLUDE_DIRECTORIES( ${DIET_INCLUDE_DIR} )
LINK_DIRECTORIES( ${DIET_LIBRARY_DIR} )

### Define a simple server...
ADD_EXECUTABLE( simple_server simple_server.c )
TARGET_LINK_LIBRARIES( simple_server ${DIET_SERVER_LIBRARIES} )
INSTALL_TARGETS( /bin simple_server )

### ... and it's associated simple client.
ADD_EXECUTABLE( simple_client simple_client.c )
TARGET_LINK_LIBRARIES( simple_client ${DIET_CLIENT_LIBRARIES} )
INSTALL_TARGETS( /bin simple_client )
\end{verbatim}
}

In order to test drive the cmake configuration of this example, and
assuming the \texttt{DIET\_HOME} points to a directory containing
an installation of \diet, simply try:

{\footnotesize
\begin{verbatim}
export DIET_HOME=<path_to_a_DIET_instal_directory>
cd doc/ExternalExample
mkdir Bin
cd Bin
cmake -DDIET_DIR:PATH=$DIET_HOME -DCMAKE_INSTALL_PREFIX:PATH=/tmp/DIETSimple ..
make
make install
\end{verbatim}
}
